[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Czech Vegetation Database",
    "section": "",
    "text": "This is a website of the Czech National Phytosociological Database, here referred to as Czech Vegetation Database, curated under Department of Botany and Zoology, Faculty of Science, Masaryk University, Brno, Czech Republic.\n\n\nWebsite Navigation\n\nAbout\nData availability\nData processing Tutorial\n\nWebpage prepared by Irena Axmanov√° and Kl√°ra Friesov√°",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/basic_analyses.html",
    "href": "DataProcessingTutorial/basic_analyses.html",
    "title": "Basic data analyses",
    "section": "",
    "text": "In this tutorial we will show you how to sort and filter the data. We will also train how to append traits, indicator values or information about status of species and calculate proportions of selected plant groups, community weighted and unweighted means or other summary statistics. If you are interested in more general overview of the functions, you are encouraged to check also our study materials here.\nlibrary(tidyverse)\nlibrary(janitor)",
    "crumbs": [
      "Data processing tutorial",
      "Basic data analyses"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/basic_analyses.html#basic-data-handling",
    "href": "DataProcessingTutorial/basic_analyses.html#basic-data-handling",
    "title": "Basic data analyses",
    "section": "2.1 Basic data handling",
    "text": "2.1 Basic data handling\nWe will play a bit with measured variables from our plots and try few useful functions. For more see study materials and links there.\n\ndata&lt;- read_csv(\"data/axmanova_forest_env_extra.csv\") %&gt;% clean_names()\n\nRows: 65 Columns: 22\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \",\"\nchr  (1): ForestTypeName\ndbl (21): Releve_nr, ForestType, Herbs, Juveniles, CoverE1, Biomass, Soil_de...\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nSelect extracts columns/variables based on their names or position. Select can be also used in combination with stringr package to identify the pattern in the names: try several options: starts_with, ends_with or more general one contains. With the use of select in your script you can order the variables always in the same way e.g.¬†ID, forest type, species number, productivity, even during import. And you can also rename the variables using select, to get exactly what you need.\n\ndata %&gt;% \n  select(ID=releve_nr, forest_type=forest_type_name, species_nr=herbs, productivity=biomass) \n\n# A tibble: 65 √ó 4\n      ID forest_type         species_nr productivity\n   &lt;dbl&gt; &lt;chr&gt;                    &lt;dbl&gt;        &lt;dbl&gt;\n 1     1 oak hornbeam forest         26         12.8\n 2     2 oak forest                  13          9.9\n 3     3 oak forest                  14         15.2\n 4     4 oak forest                  15         16  \n 5     5 oak forest                  13         20.7\n 6     6 oak forest                  16         46.4\n 7     7 oak forest                  17         49.2\n 8     8 oak hornbeam forest         21         48.7\n 9     9 oak hornbeam forest         15         13.8\n10    10 oak forest                  14         79.1\n# ‚Ñπ 55 more rows\n\n\nDistinct is a function that takes your data and remove all the duplicate rows, keeping only the unique ones. There are many cases where you will really appreciate this elegant and easy way. For example, I want a list of unique PlotIDs= releve_nr, unique combinations of two categories etc. Here I want to prepare list of forest types codes and names.\n\ndata %&gt;%\n  arrange(forest_type) %&gt;%\n  distinct(forest_type, forest_type_name)\n\n# A tibble: 4 √ó 2\n  forest_type forest_type_name   \n        &lt;dbl&gt; &lt;chr&gt;              \n1           1 oak forest         \n2           2 oak hornbeam forest\n3           3 ravine forest      \n4           4 alluvial forest    \n\n\nWhen we have a large dataset, we sometimes need to create a subset of the rows/cases. First we have to define upon which variable we are going to filter the rows (e.g.¬†Forest type, soil pH‚Ä¶) and which values are acceptable and which are not.\n\ndata %&gt;% \n  filter(forest_type_name ==\"alluvial forest\")\n\n# A tibble: 11 √ó 22\n   releve_nr forest_type forest_type_name herbs juveniles cover_e1 biomass\n       &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;\n 1       101           4 alluvial forest     28         6       90    91.1\n 2       103           4 alluvial forest     35         5       80   114. \n 3       104           4 alluvial forest     25        11       85   188. \n 4       110           4 alluvial forest     37         4       95   126. \n 5       111           4 alluvial forest     26        10       85    84.8\n 6       113           4 alluvial forest     37        10       70    74.5\n 7       125           4 alluvial forest     25         8       95   123. \n 8       127           4 alluvial forest     53         6        0   176  \n 9       129           4 alluvial forest     31         7       85   100. \n10       131           4 alluvial forest     59         3       95   163. \n11       132           4 alluvial forest     60         7       90   287. \n# ‚Ñπ 15 more variables: soil_depth_categ &lt;dbl&gt;, p_h_k_cl &lt;dbl&gt;, slope &lt;dbl&gt;,\n#   altitude &lt;dbl&gt;, canopy_e3 &lt;dbl&gt;, radiation &lt;dbl&gt;, heat &lt;dbl&gt;,\n#   trans_dir &lt;dbl&gt;, trans_dif &lt;dbl&gt;, trans_tot &lt;dbl&gt;, eiv_light &lt;dbl&gt;,\n#   eiv_moisture &lt;dbl&gt;, eiv_soilreaction &lt;dbl&gt;, eiv_nutrients &lt;dbl&gt;, twi &lt;dbl&gt;",
    "crumbs": [
      "Data processing tutorial",
      "Basic data analyses"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/basic_analyses.html#join-and-summarise",
    "href": "DataProcessingTutorial/basic_analyses.html#join-and-summarise",
    "title": "Basic data analyses",
    "section": "2.2 Join and summarise",
    "text": "2.2 Join and summarise",
    "crumbs": [
      "Data processing tutorial",
      "Basic data analyses"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/basic_analyses.html#community-weighted-means",
    "href": "DataProcessingTutorial/basic_analyses.html#community-weighted-means",
    "title": "Basic data analyses",
    "section": "2.3 Community weighted means",
    "text": "2.3 Community weighted means",
    "crumbs": [
      "Data processing tutorial",
      "Basic data analyses"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/basic_analyses.html#ellenberg-indicator-values",
    "href": "DataProcessingTutorial/basic_analyses.html#ellenberg-indicator-values",
    "title": "Basic data analyses",
    "section": "2.4 Ellenberg indicator values",
    "text": "2.4 Ellenberg indicator values",
    "crumbs": [
      "Data processing tutorial",
      "Basic data analyses"
    ]
  },
  {
    "objectID": "About/turboveg_windows.html",
    "href": "About/turboveg_windows.html",
    "title": "Turboveg for Windows",
    "section": "",
    "text": "The data are stored in the TURBOVEG 2 database management program developed by Stephan Hennekens (Hennekens & Schamin√©e 2001), which is a European standard software for vegetation-plot databases.\n\nInstallation\nIf you are interested in the Czech version of Turboveg, contact Ilona Knollov√° (üìß ikuzel@sci.muni.cz) or Milan Chytr√Ω (üìß chytry@sci.muni.cz). International users have to contact coordinators in their countries or directly Stephan Hennnekens.\n\n\nUpdates\nWe recommend to check out for updates of Turboveg (here, select ‚ÄûInternational, single user version‚Äú).\nUpdates of common databases (for Czech Turboveg only):\n\nSpecies list: species.zip (28.11.2024)\nPopup list (database dictionary): popup.zip (16.12.2024)\n\nExtract the file species.zip and add the folder Czechia_Slovakia_2015 to the folder /TURBOWIN/species. In the Turboveg program, assign the species list using modify database attributes to the specific database. Extract the file popup.zip to the folder /TURBOWIN/popup (old files should be rewritten).\nNEW\n11.10.2022 New syntaxon list ‚Äì The header data field ‚ÄûSYNTAXON‚Äú newly follows syntaxon list according to monography Vegetace ƒåesk√© republiky (Chytr√Ω et al.¬†2007‚Äì2013). Original syntaxon list (Moravec et al.¬†1995) is now located in the header data field ‚ÄûSyntaxon MORAVEC‚Äú. The change of structure requires downloading new popup list (details here).\n\n\nInstructions\nEach author may enter phytosociological relev√©s into the database only under specific numbers assigned by the regional coordinator. If the relev√©s are taken from published sources, bibliographic references entered should be from within the same numerical range. The list of assigned numbers is here.\nThe collaborators who were not assigned to a range of relev√© numbers should code their relev√©s from No.¬†1. Their relev√©s will be renumbered by the coordinator once they are sent to the central database.\nTurboveg manual for beginners (in Czech) is here. You can download empty database here with defined standard header data fields used in the Czech National Phytosociological Database. Restore the empty database to the folder /TURBOWIN/data and rename it.\nNomenclature of vascular plant species in the Czech National Phytosociological Database follows an updated version of Liste der Gef√§√üpflanzen Mitteleuropas (Ehrendorfer 1973), prepared by Harald Niklfeld and Walter Gutermann, with additions of species included in Key to the flora of the Czech Republic (Kub√°t et al.¬†2002). Names of bryophytes and lichens follow Frey et al.¬†(1995) and Pi≈°√∫t et al.¬†(1993). The species list used in the Czech National Phytosociological Database, called Czechia_Slovakia_2015, is identical with that used in the Central Database of Phytosociological Relev√©s in Slovakia. The list of syntaxa used in the Czech installation of TURBOVEG follows Moravec et al.¬†(1995).\n\n\nReferences:\n\nChytr√Ω M. (ed.) (2007): Vegetace ƒåesk√© republiky 1. Travinn√° a ke≈ô√≠ƒçkov√° vegetace. Vegetation of the Czech Republic 1. Grassland and heathland vegetation. Academia, Praha.\nChytr√Ω M. (ed.) (2009): Vegetace ƒåesk√© republiky 2. Ruder√°ln√≠, plevelov√°, skaln√≠ a su≈•ov√° vegetace. Vegetation of the Czech Republic 2. Ruderal, weed, rock and scree vegetation. Academia, Praha.\nChytr√Ω M. (ed.) (2011): Vegetace ƒåesk√© republiky 3. Vodn√≠ a mok≈ôadn√≠ vegetace. Vegetation of the Czech Republic 3. Aquatic and wetland vegetation. Academia, Praha.\nChytr√Ω M. (ed.) (2013): Vegetace ƒåesk√© republiky 4. Lesn√≠ a k≈ôovinn√° vegetace. Vegetation of the Czech Republic 4. Forest and scrub vegetation. Academia, Praha.\nEhrendorfer F. (ed.) (1973): Liste der Gef√§√üpflanzen Mitteleuropas. Ed. 2. G. Fischer, Stuttgart.\nFrey W., Frahm J. P., Fischer E. & Lobin W. (1995): Die Moos- und Farnpflanzen Europas. G. Fischer, Stuttgart.\nHennekens S.M. & Schamin√©e J.H.J. (2001): TURBOVEG, a comprehensive data base management system for vegetation data. Journal of Vegetation Science, 12: 589‚Äì591. [pdf]\nKub√°t K., Hrouda L., Chrtek J. jun., Kaplan Z., Kirschner J. & ≈†tƒõp√°nek J. (eds.) (2002): Kl√≠ƒç ke kvƒõtenƒõ ƒåesk√© Republiky. Academia, Praha.\nMoravec J., Bal√°tov√°-Tul√°ƒçkov√° E., Bla≈ækov√° D., Hadaƒç E., Hejn√Ω S., Hus√°k ≈†., Jen√≠k J., Kolbek J., Krahulec F., Krop√°ƒç Z., Neuh√§usl R., Rybn√≠ƒçek K., ≈òeho≈ôek V. & Vicherek J. (1995): Rostlinn√° spoleƒçenstva ƒåesk√© republiky a jejich ohro≈æen√≠ (Red list of plant communities of the Czech Republic and their endangerment). Ed. 2. Severoƒçes. P≈ô√≠r., Suppl. 1995: 1‚Äì206.\nPi≈°√∫t I., Lackovicov√° A. & Lisick√° E. (1993): S√∫pis li≈°ajn√≠kov Slovenska. Biol√≥gia, 48, Suppl. 1: 53‚Äì98.\n\n\n\nCoordinators\n\nCentral coordinators: Ilona Knollov√° (üìß ikuzel@sci.muni.cz) and Milan Chytr√Ω (üìß chytry@sci.muni.cz)\nMasaryk University and South Moravia: Ilona Knollov√° (üìß ikuzel@sci.muni.cz)\nCzech University of Life Sciences Prague, Institute of Botany of the Czech Academy of Sciences and Charles University in Prague: Tom√°≈° ƒåern√Ω (üìß cernyt@fld.czu.cz)\nUniversity of South Bohemia and South Bohemia: Milan ≈†tech (üìß stech@prf.jcu.cz)",
    "crumbs": [
      "About",
      "Turboveg for Windows"
    ]
  },
  {
    "objectID": "About/current_state.html",
    "href": "About/current_state.html",
    "title": "Current state",
    "section": "",
    "text": "Current state\nIn July 2020 the central database contained more than 113 800 relev√©s from the territory of the Czech Republic. Most relev√©s belong to phytosociological classes of broad-leaved forests (Querco-Fagetea), meadows and mesic pastures (Molinio-Arrhenatheretea), marshes (Phragmito-Magno-Caricetea), dry grasslands (Festuco-Brometea) and disturbed vegetation of wet to mesic habitats (Galio-Urticetea). Phytosociological bibliography of the Czech Republic, with an indication which data sources have been digitized and included in the database, is available here.\n\nFig. 1. Distribution of relev√©s in the database. The symbol size scale is based on Natural Breaks.\n\nFig. 2. Number of relev√©s in the database through time.\n\n\nFig. 3. Number of relev√©s in the database by phytosociological classes.\n\n\n\nContacts\nMUNI\nDepartment of Botany and Zoology,Faculty of Science,Masaryk University\nPostal Address\nKotl√°≈ôsk√° 267/2, 611 37 Brno, Czech Republic\nPhysical Address\nUniversity Campus Bohunice, building A32, Kamenice 753/5, Brno, Czech Republic",
    "crumbs": [
      "About",
      "Current state"
    ]
  },
  {
    "objectID": "About/acknowledgements.html",
    "href": "About/acknowledgements.html",
    "title": "Acknowledgements",
    "section": "",
    "text": "We thank all the contributors of the Czech National Phytosociological Database:\n\n\n\n\nIrena Axmanov√° (Vesel√°)\nLucie Benediktov√°\nEli≈°ka Bla≈æejov√° (Horodysk√°)\nDenisa Bla≈ækov√°\nKarel Boubl√≠k\nKate≈ôina Bub√≠kov√°\nLucia Cachovanov√°\nJaroslava Cieslarov√°\nDavid Cig√°nek\n≈†√°rka Cimalov√°\nJaroslav ƒå√°p\nAl≈æbƒõta ƒåejkov√°\nBarbora ƒåepelov√°\nMartin ƒåern√Ω\nTom√°≈° ƒåern√Ω\nPavel Danƒõk\nJi≈ô√≠ Danihelka\nAlice Dingov√°\nDaniel D√≠tƒõ\nJan Div√≠≈°ek\nCtibor Dolej≈°√≠\nJana ƒéoubalov√°\nJan Douda\nPavel D≈ôevojan\nLydie Dudov√° (Navr√°tilov√°)\nMartin Duchoslav\nHelena Du≈°kov√°\nJana Dvo≈ô√°kov√°\nLibor Ekrt\nViktoria Eltsova\nMartina Fab≈°iƒçov√°\nKarel Fajmon\nZuzana Fajmonov√° (Rozbrojov√°)\nPetr Filippov\nJarmila Filippovov√°\nZuzana Fronkov√°\nJi≈ô√≠ Galda\nMichal Ger≈æa\nMarek Gonda\nTom√°≈° Grulich\nMichal H√°jek\nPetra H√°jkov√°\nJana Hal√∫zov√°\nPetra Han√°kov√°\nHandrij H√§rtel\nHelena Havr√°nkov√°\nRadim H√©dl\nMonika Hejdov√°\nAle≈° Hoffmann\nDana Holubov√° (Michalcov√°)\nViera Hor√°kov√°\nLucie Hradilov√°\nRichard Hrivn√°k\nZdenka Hroudov√°\nJaroslav Hruban\nMonika Hrubanov√° (Dr≈°kov√°)\nJind≈ôich Chlapek\n\n\n\n\nMark√©ta Chudomelov√°\nKry≈°tof Chytr√Ω\nIvan Jindra\nMartin Jirou≈°ek\nJana Jirou≈°kov√° (Bo≈ækov√°)\nBlanka J√≠r≈Ø\nTereza Ju≈ôenov√° (Koubkov√°)\nJan Ju≈ôica\nMichal Ju≈ô√≠ƒçek\nJi≈ô√≠ Ju≈ôiƒçka\nKamila Ju≈ôiƒçkov√°\nVeronika Kaln√≠kov√°\nVeronika Kalusov√°\nZdenƒõk Kaplan\nKatrin Karimov√°\nPetr Karl√≠k\nAlexandra Klaudisov√°\nLeo≈° Klime≈°\nIlona Knollov√° (Ku≈æelov√°)\nMartin Koƒç√≠\nFranti≈°ek Krahulec\nLucie Kratochv√≠lov√°\nZdenƒõk Krop√°ƒç\nPavel K≈ô√≠≈æek\nTom√°≈° Kuƒçera\nAnna Kul√≠kov√°\nPetr Kune≈°\nJana K≈Ørov√°\nJosef Kutlva≈°r\nJitka Laburdov√°\nFlavia Landucci\nDeana L√°n√≠kov√° (Simonov√°)\nMartin Lep≈°√≠\nJarmila Lorencov√° (Urb√°nkov√°)\nZde≈àka Lososov√°\nHana Luk≈°√≠kov√°\nPavel Lustyk\nSamuel Lvonƒç√≠k\nMartina Mack≈Ø (Nejezchlebov√°)\nMichal Maz√°k\nKristina Merunkov√°\nZuzana My≈°kov√°\nTereza N√°hl√≠kov√°\nJana Navr√°tilov√°\nJi≈ô√≠ Nƒõmec\nZdenka Neuh√§uslov√°\nJana Nov√°\nJan Nov√°k\nPavel Nov√°k\nIvan Ostr√Ω\nMarcela Paloudov√°\nPetra Pavl√≠ƒçkov√°\nSylvie Pech√°ƒçkov√°\nJan Pergl\nTom√°≈° Peterka\nMichaela Petrov√°\nPetr Pet≈ô√≠k\n\n\n\n\nKate≈ôina Pi≈°≈•kov√°\nZuzana Pleskov√°\nMarie Popel√°≈ôov√°\nJan Pranƒçl\nZdenka Preislerov√° (Ot√Ωpkov√°)\nHelena Proke≈°ov√°\nPetr Py≈°ek\nMarie Rafajov√°\nFrank Richter\nLudmila Rivolov√°\nJan Roleƒçek\nRomana Rouƒçkov√°\nJi≈ô√≠ Rozehnal\nEva Rozehnalov√°\nMarcela ≈òezn√≠ƒçkov√°\nJi≈ô√≠ S√°dlo\nVojtƒõch Sedl√°ƒçek\nHana Sekerkov√°\nMartina Sojnekov√°\nZdenƒõk Sold√°n\nZbynƒõk Sov√≠k\nLenka Sov√≠kov√°\nVeronika Srnkov√°\nLenka Sta≈àkov√°\nTom√°≈° Svaƒçina\nMilan ≈†enk√Ω≈ô\nAnna ≈†√≠mov√°\nPetr ≈†marda\nEva ≈†merdov√° (Hettenbergerov√°)\nMark√©ta ≈†pelinov√°\nPetra ≈†tƒõp√°nkov√°\nJitka ≈†tƒõrbov√° (Effmertov√°)\nKate≈ôina ≈†umberov√°\nMark√©ta T√°borsk√°\nP≈ôemysl Tajek\nLubom√≠r Tich√Ω\nJana Tkaƒç√≠kov√°\nAdam Trƒçka\nMartin Veƒçe≈ôa\nAdam Veleba\nJi≈ô√≠ Velebil\nJi≈ô√≠ Vicherek\nOnd≈ôej Vild\nKarla Vincenecov√°\nRichard Vi≈°≈à√°k\nMichaela V√≠tkov√°\nPavla Vlƒçkov√°\nMartin Voj√≠k\nJaroslav Vojta\nAlena Vydrov√°\nTom√°≈° Vymyslick√Ω\nPetr Vyslou≈æil\nTom√°≈° Zed√≠nek\nDavid Zelen√Ω\nIva Z√≠tkov√°\nDominik Zukal\nKrist√Ωna ≈Ω√°kov√°",
    "crumbs": [
      "About",
      "Acknowledgements"
    ]
  },
  {
    "objectID": "About/introduction.html",
    "href": "About/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Czech National Phytosociological Database\nThe Czech National Phytosociological Database (CNPD) is collecting digital vegetation-plot records (phytosociological relev√©s) from the territory of the Czech Republic in a single database, which facilitate easy access to relevant data for vegetation survey, ecological analyses and applications in nature conservation. These activities are a part of broader European projects coordinated by the Working Group for European Vegetation Survey of the (International Association for Vegetation Science). CNPD closely cooperates with the European Vegetation Archive (EVA) and the Global Vegetation Database (sPlot). The database was established with the help of the Darwin Initiative project coordinated by Professor John Rodwell at Lancaster University, UK (1995‚Äì1998). Since 1999 the database project has been funded from various projects of Masaryk University, most of them provided by the Czech Science Foundation.\nThe Czech National Phytosociological Database is coordinated at the Department of Botany and Zoology, Masaryk University, Brno. The coordinators of the database are Milan Chytr√Ω (üìß chytry@sci.muni.cz) and Ilona Knollov√° (üìß ikuzel@sci.muni.cz), and there are local coordinators in other academic institutions in the Czech Republic. An integral part of the database project is the development of methods for data analysis. Major procedures developed so far are available in the JUICEsoftware developed by Lubom√≠r Tich√Ω.\nThe basic statistics about the Czech National Phytosociological Database were published by Chytr√Ω & Rafajov√° (2003), with an update in a short report by Chytr√Ω & Michalcov√° (2012). The database is registered in the Global Index of Vegetation-plot Databases (GIVD, Dengler et al.¬†2011) with the code EU-CZ-001.\n\n\nRecommended citation\nChytr√Ω M. & Rafajov√° M. (2003): Czech National Phytosociological Database: basic statistics of the available vegetation-plot data. Preslia 75: 1‚Äì15. [pdf]",
    "crumbs": [
      "About",
      "Introduction"
    ]
  },
  {
    "objectID": "DataAvailability/data_availability.html",
    "href": "DataAvailability/data_availability.html",
    "title": "Data availability",
    "section": "",
    "text": "Data from the Czech National Phytosociological Database (CNPD) are available directly from CNPD (for analyses at the national scale), from EVA (for analyses at the international scale within Europe) and from sPlot (for global analyses). Species occurrence data are available in the Pladias database. There are three regimes of data availability:\n\nPublic data freely available online.\nData available upon request from database managers for academic research or applications in nature conservation, but not for commercial purposes. Data requests should be sent by e-mail to Ilona Knollov√° (üìß ikuzel@sci.muni.cz) or Milan Chytr√Ω (üìß chytry@sci.muni.cz) with a description of the intended use of the data and criteria of data selection (e.g.¬†area, vegetation type and time interval) and the required format.\nNon-public data, which are stored in the central database but not made available to the public, or made available only for specific purposes specified by the data provider.\n\nData use in publications should be acknowledged using the standard database citation:\nChytr√Ω M. & Rafajov√° M. (2003): Czech National Phytosociological database: basic statistics of the available vegetation-plot data. Preslia 75: 1‚Äì15.\nThe papers where the data were published or authors of unpublished data should also be cited. These citations can be omitted if a data set from many different sources is used, in which no source is notably prevailing, and if the type of publication does not allow citing all the sources.",
    "crumbs": [
      "Data availability"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/data_processing_tutorial.html",
    "href": "DataProcessingTutorial/data_processing_tutorial.html",
    "title": "Data processing tutorial",
    "section": "",
    "text": "We want to provide tutorial on how to import data from the Turboveg database and how to process it further in R, run basic analyses and prepare data for export to other formats.\n\nWe are using tidyverse approach and tidy data rules. If you are interested in more details and links for more literature, check our study materials here.\nFor data processing we recommend to use a project in R studio. The advantage of using projects, is that you can directly use the same structure with exactly the same paths as provided in this tutorial. For this, add subfolder ‚Äúdata‚Äù directly to the main folder, to store all the data files.\nWe show all the data processing at the example of forest understory data from the Czech Vegetation Database. If you want to train in the same way as is described in the tutorials, you can download the data as zip file here Link to Github folderor the whole project as zip Link to Github folder.\nIn individual subchapters you can find instructions and individual parts of the code, that you can copy and insert them to your own script (use copy icon in the upper right corner to copy individual code chunks).\n\nPlease note that we do not provide the whole script, but we encourage you to copy the code chunks from the examples here and use them to build your own script, adjusted to your needs.\nAt the begining of your work, load the following libraries. If needed, first install those missing by function install.packages(\"packageName\")\n\nlibrary(foreign)   #for reading dbf files \nlibrary(tidyverse) #for data handling, pipes and visualisation \nlibrary(readxl)    #for data import directly from Excel \nlibrary(janitor)   #for unified, easy-to-handle format of variable names\n\nWe are using pipes %&gt;% throughout the scripts. Pipes allows the output of a previous command to be used as input to another command instead of using nested functions. It means, pipe binds individual steps into a sequence and it reads from left to right. You can insert it into your code as ctrl+shift+M.\nTo play a bit with the pipes, you can take part of the script, send it to the console with ctrl+enter and just try if and how it works without assigning it to final object as in the picture below.",
    "crumbs": [
      "Data processing tutorial"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/export.html",
    "href": "DataProcessingTutorial/export.html",
    "title": "Export to other formats",
    "section": "",
    "text": "There are two main ways how the data can be organised across rows and columns. Wide or long format. We will show you an example of spruce forest data, where we recorded plant species in several sites and at each site we also estimated their abundance, here approximated as percentage cover (higher value means that the species covered larger area of the surveyed vegetation plot, but we do not give the area itself, just value relatively to the total area, i.e.¬†percentage of total area). The covers of species might overlap, as they grow in different heights.\n\nWide format is more conservative and used in many older packages for ecological data analysis. In our example we list all species and the colums are used to indicate their abundance at each site. This is the way you need to prepare your species matrix for ordinations in vegan. However, wide format has also many cons.\nOne of them is the size of the file. In the example above, there are abundance of given plants in each of the site. When the species is present in just one site, here Trientalis europaea, it is still keeping space across the whole table, where there can be hundreds or thousands of sites. The table code is then of course memory demanding. Another disadvantage is that you cannot add easily new information to the listed species. If you for example want to separate species that are in a tree vegetation layer (recognised in vegetation ecology as 1), herb layer (6) and moss layer (9), you would have to add this information to the name of the species e.g.¬†Picea_abies_1.\n\nLong format in contrast, is great for handling large datasets. We can also add any information, describing the data, such as vegetation layers, growth forms, native/alien status etc. After that we can very simply filter, summarise and calculate further statistics.\n\nlibrary(tidyverse) \nlibrary(readxl) \nlibrary(janitor)\n\nWe will upload the species data saved in a long format and transform it into a matrix =wide format, so that it can be used in specific ecological analyses e.g.¬†in vegan.\n\nspe &lt;- read_csv(\"data/spe.csv\") \n\nNew names:\nRows: 4583 Columns: 6\n‚îÄ‚îÄ Column specification\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Delimiter: \",\" chr\n(1): species dbl (5): ...1, releve_nr, nonvascular, layer, cover_perc\n‚Ñπ Use `spec()` to retrieve the full column specification for this data. ‚Ñπ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n‚Ä¢ `` -&gt; `...1`\n\ntibble(spe)\n\n# A tibble: 4,583 √ó 6\n    ...1 releve_nr species                   nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex digitata                      0     6        0.5\n 2     2    183111 Carpinus betulus                    0     7        3  \n 3     3    183111 Cytisus nigricans                   0     6        0.1\n 4     4    183111 Festuca ovina                       0     6        3  \n 5     5    183111 Fraxinus excelsior                  0     7        0.1\n 6     6    183111 Galium rotundifolium                0     6        0.1\n 7     7    183111 Hieracium lachenalii                0     6        3  \n 8     8    183111 Hieracium murorum                   0     6        0.5\n 9     9    183111 Hieracium sabaudum s.lat.           0     6        0.1\n10    10    183111 Hypericum perforatum                0     6        0.1\n# ‚Ñπ 4,573 more rows\n\n\nWe can see that there are plant species names sorted by releve_nr, where each number indicates a vegetation record from one specific site (can be also called vegetation plot or sample). We may need to change the species names to be in the compact format, without any spaces, just underscores. For this we will use mutate function with str_replace (for string specification) indicating that each space should be changed to underscore and we will directly apply it to the original column.\n\nspe %&gt;%    \n  mutate(species = str_replace_all(species, \" \", \"_\"))\n\n# A tibble: 4,583 √ó 6\n    ...1 releve_nr species                   nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex_digitata                      0     6        0.5\n 2     2    183111 Carpinus_betulus                    0     7        3  \n 3     3    183111 Cytisus_nigricans                   0     6        0.1\n 4     4    183111 Festuca_ovina                       0     6        3  \n 5     5    183111 Fraxinus_excelsior                  0     7        0.1\n 6     6    183111 Galium_rotundifolium                0     6        0.1\n 7     7    183111 Hieracium_lachenalii                0     6        3  \n 8     8    183111 Hieracium_murorum                   0     6        0.5\n 9     9    183111 Hieracium_sabaudum_s.lat.           0     6        0.1\n10    10    183111 Hypericum_perforatum                0     6        0.1\n# ‚Ñπ 4,573 more rows\n\n\nWe have the condensed name with underscores, but there are still more variables in the table. We can either remove them or merge them to be included in the final wide format. Here we will go a bit against tidy rules and add the information about the vegetation layer directly to the variable Species using unite function from the package tidyr which merges strings from two or more columns into a new one: A+B =A_B. Default separator is again underscore, unless you specify it differently by sep=XX argument.\n\nArgument na.rm indicates what to do if in one of the combined columns there is no value but NA. We have set this argument to TRUE to remove the NA. If you keep it FALSE it can happen that in some data the new string will be a_NA or NA_b, or even NA_NA (see line 4 of our example).\nRemove argument set to TRUE will remove the original columns which we used to combine the new one (in the example above you will have only z). In our case we will keep original columns for visual checking and we will use select function in the next step to remove them.\nNote that function that works in an opposite direction is called separate or separate_wider_delim\n\nspe %&gt;%   \n  mutate(species = str_replace_all(species, \" \", \"_\"))%&gt;%   \n  unite(\"species_layer\", species,layer, na.rm = TRUE, remove = FALSE) \n\n# A tibble: 4,583 √ó 7\n    ...1 releve_nr species_layer            species nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                    &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex_digitata_6         Carex_‚Ä¶           0     6        0.5\n 2     2    183111 Carpinus_betulus_7       Carpin‚Ä¶           0     7        3  \n 3     3    183111 Cytisus_nigricans_6      Cytisu‚Ä¶           0     6        0.1\n 4     4    183111 Festuca_ovina_6          Festuc‚Ä¶           0     6        3  \n 5     5    183111 Fraxinus_excelsior_7     Fraxin‚Ä¶           0     7        0.1\n 6     6    183111 Galium_rotundifolium_6   Galium‚Ä¶           0     6        0.1\n 7     7    183111 Hieracium_lachenalii_6   Hierac‚Ä¶           0     6        3  \n 8     8    183111 Hieracium_murorum_6      Hierac‚Ä¶           0     6        0.5\n 9     9    183111 Hieracium_sabaudum_s.la‚Ä¶ Hierac‚Ä¶           0     6        0.1\n10    10    183111 Hypericum_perforatum_6   Hyperi‚Ä¶           0     6        0.1\n# ‚Ñπ 4,573 more rows\n\n\nAt this point we have everything we need to use it as input for the wide format table: releve_nr. species_layer and values of the abundance saved as cover_perc. One more step is to select only these or to deselect (-) those not needed.\n\nspe %&gt;%   \n  mutate(species = str_replace_all(species, \" \", \"_\"))%&gt;%   \n  unite(\"species_layer\", species,layer, na.rm = TRUE, remove = FALSE)\n\n# A tibble: 4,583 √ó 7\n    ...1 releve_nr species_layer            species nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                    &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex_digitata_6         Carex_‚Ä¶           0     6        0.5\n 2     2    183111 Carpinus_betulus_7       Carpin‚Ä¶           0     7        3  \n 3     3    183111 Cytisus_nigricans_6      Cytisu‚Ä¶           0     6        0.1\n 4     4    183111 Festuca_ovina_6          Festuc‚Ä¶           0     6        3  \n 5     5    183111 Fraxinus_excelsior_7     Fraxin‚Ä¶           0     7        0.1\n 6     6    183111 Galium_rotundifolium_6   Galium‚Ä¶           0     6        0.1\n 7     7    183111 Hieracium_lachenalii_6   Hierac‚Ä¶           0     6        3  \n 8     8    183111 Hieracium_murorum_6      Hierac‚Ä¶           0     6        0.5\n 9     9    183111 Hieracium_sabaudum_s.la‚Ä¶ Hierac‚Ä¶           0     6        0.1\n10    10    183111 Hypericum_perforatum_6   Hyperi‚Ä¶           0     6        0.1\n# ‚Ñπ 4,573 more rows\n\n\nNow we can finaly use the pivot wider function to transform the data. We have to specify from where we are taking the names of new variables (names_from) and from where we should take the values which should appear in the table (values_from). Since we changed the format, all species, even those not occurring in that particular site/plot have to get some values. Therefore, one more step is to fill the empty cells by zeros using values_fill. In this case we can do that, because we know that if the species was absent its abundance was exactly 0.\n\nspe %&gt;%   \n  mutate(species = str_replace_all(species, \" \", \"_\"))%&gt;%   \n  unite(\"species_layer\", species,layer, na.rm = TRUE, remove = FALSE)%&gt;%\n  pivot_wider(names_from = species_layer, \n              values_from = cover_perc, \n              values_fill = 0) -&gt; spe_wide",
    "crumbs": [
      "Data processing tutorial",
      "Export to other formats"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/export.html#long-to-wide-format",
    "href": "DataProcessingTutorial/export.html#long-to-wide-format",
    "title": "Export to other formats",
    "section": "",
    "text": "There are two main ways how the data can be organised across rows and columns. Wide or long format. We will show you an example of spruce forest data, where we recorded plant species in several sites and at each site we also estimated their abundance, here approximated as percentage cover (higher value means that the species covered larger area of the surveyed vegetation plot, but we do not give the area itself, just value relatively to the total area, i.e.¬†percentage of total area). The covers of species might overlap, as they grow in different heights.\n\nWide format is more conservative and used in many older packages for ecological data analysis. In our example we list all species and the colums are used to indicate their abundance at each site. This is the way you need to prepare your species matrix for ordinations in vegan. However, wide format has also many cons.\nOne of them is the size of the file. In the example above, there are abundance of given plants in each of the site. When the species is present in just one site, here Trientalis europaea, it is still keeping space across the whole table, where there can be hundreds or thousands of sites. The table code is then of course memory demanding. Another disadvantage is that you cannot add easily new information to the listed species. If you for example want to separate species that are in a tree vegetation layer (recognised in vegetation ecology as 1), herb layer (6) and moss layer (9), you would have to add this information to the name of the species e.g.¬†Picea_abies_1.\n\nLong format in contrast, is great for handling large datasets. We can also add any information, describing the data, such as vegetation layers, growth forms, native/alien status etc. After that we can very simply filter, summarise and calculate further statistics.\n\nlibrary(tidyverse) \nlibrary(readxl) \nlibrary(janitor)\n\nWe will upload the species data saved in a long format and transform it into a matrix =wide format, so that it can be used in specific ecological analyses e.g.¬†in vegan.\n\nspe &lt;- read_csv(\"data/spe.csv\") \n\nNew names:\nRows: 4583 Columns: 6\n‚îÄ‚îÄ Column specification\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Delimiter: \",\" chr\n(1): species dbl (5): ...1, releve_nr, nonvascular, layer, cover_perc\n‚Ñπ Use `spec()` to retrieve the full column specification for this data. ‚Ñπ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n‚Ä¢ `` -&gt; `...1`\n\ntibble(spe)\n\n# A tibble: 4,583 √ó 6\n    ...1 releve_nr species                   nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex digitata                      0     6        0.5\n 2     2    183111 Carpinus betulus                    0     7        3  \n 3     3    183111 Cytisus nigricans                   0     6        0.1\n 4     4    183111 Festuca ovina                       0     6        3  \n 5     5    183111 Fraxinus excelsior                  0     7        0.1\n 6     6    183111 Galium rotundifolium                0     6        0.1\n 7     7    183111 Hieracium lachenalii                0     6        3  \n 8     8    183111 Hieracium murorum                   0     6        0.5\n 9     9    183111 Hieracium sabaudum s.lat.           0     6        0.1\n10    10    183111 Hypericum perforatum                0     6        0.1\n# ‚Ñπ 4,573 more rows\n\n\nWe can see that there are plant species names sorted by releve_nr, where each number indicates a vegetation record from one specific site (can be also called vegetation plot or sample). We may need to change the species names to be in the compact format, without any spaces, just underscores. For this we will use mutate function with str_replace (for string specification) indicating that each space should be changed to underscore and we will directly apply it to the original column.\n\nspe %&gt;%    \n  mutate(species = str_replace_all(species, \" \", \"_\"))\n\n# A tibble: 4,583 √ó 6\n    ...1 releve_nr species                   nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex_digitata                      0     6        0.5\n 2     2    183111 Carpinus_betulus                    0     7        3  \n 3     3    183111 Cytisus_nigricans                   0     6        0.1\n 4     4    183111 Festuca_ovina                       0     6        3  \n 5     5    183111 Fraxinus_excelsior                  0     7        0.1\n 6     6    183111 Galium_rotundifolium                0     6        0.1\n 7     7    183111 Hieracium_lachenalii                0     6        3  \n 8     8    183111 Hieracium_murorum                   0     6        0.5\n 9     9    183111 Hieracium_sabaudum_s.lat.           0     6        0.1\n10    10    183111 Hypericum_perforatum                0     6        0.1\n# ‚Ñπ 4,573 more rows\n\n\nWe have the condensed name with underscores, but there are still more variables in the table. We can either remove them or merge them to be included in the final wide format. Here we will go a bit against tidy rules and add the information about the vegetation layer directly to the variable Species using unite function from the package tidyr which merges strings from two or more columns into a new one: A+B =A_B. Default separator is again underscore, unless you specify it differently by sep=XX argument.\n\nArgument na.rm indicates what to do if in one of the combined columns there is no value but NA. We have set this argument to TRUE to remove the NA. If you keep it FALSE it can happen that in some data the new string will be a_NA or NA_b, or even NA_NA (see line 4 of our example).\nRemove argument set to TRUE will remove the original columns which we used to combine the new one (in the example above you will have only z). In our case we will keep original columns for visual checking and we will use select function in the next step to remove them.\nNote that function that works in an opposite direction is called separate or separate_wider_delim\n\nspe %&gt;%   \n  mutate(species = str_replace_all(species, \" \", \"_\"))%&gt;%   \n  unite(\"species_layer\", species,layer, na.rm = TRUE, remove = FALSE) \n\n# A tibble: 4,583 √ó 7\n    ...1 releve_nr species_layer            species nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                    &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex_digitata_6         Carex_‚Ä¶           0     6        0.5\n 2     2    183111 Carpinus_betulus_7       Carpin‚Ä¶           0     7        3  \n 3     3    183111 Cytisus_nigricans_6      Cytisu‚Ä¶           0     6        0.1\n 4     4    183111 Festuca_ovina_6          Festuc‚Ä¶           0     6        3  \n 5     5    183111 Fraxinus_excelsior_7     Fraxin‚Ä¶           0     7        0.1\n 6     6    183111 Galium_rotundifolium_6   Galium‚Ä¶           0     6        0.1\n 7     7    183111 Hieracium_lachenalii_6   Hierac‚Ä¶           0     6        3  \n 8     8    183111 Hieracium_murorum_6      Hierac‚Ä¶           0     6        0.5\n 9     9    183111 Hieracium_sabaudum_s.la‚Ä¶ Hierac‚Ä¶           0     6        0.1\n10    10    183111 Hypericum_perforatum_6   Hyperi‚Ä¶           0     6        0.1\n# ‚Ñπ 4,573 more rows\n\n\nAt this point we have everything we need to use it as input for the wide format table: releve_nr. species_layer and values of the abundance saved as cover_perc. One more step is to select only these or to deselect (-) those not needed.\n\nspe %&gt;%   \n  mutate(species = str_replace_all(species, \" \", \"_\"))%&gt;%   \n  unite(\"species_layer\", species,layer, na.rm = TRUE, remove = FALSE)\n\n# A tibble: 4,583 √ó 7\n    ...1 releve_nr species_layer            species nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                    &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex_digitata_6         Carex_‚Ä¶           0     6        0.5\n 2     2    183111 Carpinus_betulus_7       Carpin‚Ä¶           0     7        3  \n 3     3    183111 Cytisus_nigricans_6      Cytisu‚Ä¶           0     6        0.1\n 4     4    183111 Festuca_ovina_6          Festuc‚Ä¶           0     6        3  \n 5     5    183111 Fraxinus_excelsior_7     Fraxin‚Ä¶           0     7        0.1\n 6     6    183111 Galium_rotundifolium_6   Galium‚Ä¶           0     6        0.1\n 7     7    183111 Hieracium_lachenalii_6   Hierac‚Ä¶           0     6        3  \n 8     8    183111 Hieracium_murorum_6      Hierac‚Ä¶           0     6        0.5\n 9     9    183111 Hieracium_sabaudum_s.la‚Ä¶ Hierac‚Ä¶           0     6        0.1\n10    10    183111 Hypericum_perforatum_6   Hyperi‚Ä¶           0     6        0.1\n# ‚Ñπ 4,573 more rows\n\n\nNow we can finaly use the pivot wider function to transform the data. We have to specify from where we are taking the names of new variables (names_from) and from where we should take the values which should appear in the table (values_from). Since we changed the format, all species, even those not occurring in that particular site/plot have to get some values. Therefore, one more step is to fill the empty cells by zeros using values_fill. In this case we can do that, because we know that if the species was absent its abundance was exactly 0.\n\nspe %&gt;%   \n  mutate(species = str_replace_all(species, \" \", \"_\"))%&gt;%   \n  unite(\"species_layer\", species,layer, na.rm = TRUE, remove = FALSE)%&gt;%\n  pivot_wider(names_from = species_layer, \n              values_from = cover_perc, \n              values_fill = 0) -&gt; spe_wide",
    "crumbs": [
      "Data processing tutorial",
      "Export to other formats"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/export.html#juice-input-files",
    "href": "DataProcessingTutorial/export.html#juice-input-files",
    "title": "Export to other formats",
    "section": "3.2 Juice input files",
    "text": "3.2 Juice input files",
    "crumbs": [
      "Data processing tutorial",
      "Export to other formats"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/turboveg_r.html",
    "href": "DataProcessingTutorial/turboveg_r.html",
    "title": "Turboveg for R",
    "section": "",
    "text": "Aim of this tutorial is to show you step by step how to import the data from Turboveg to R and prepare it for further analyses.",
    "crumbs": [
      "Data processing tutorial",
      "Turboveg to R"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/turboveg_r.html#turboveg-data-format",
    "href": "DataProcessingTutorial/turboveg_r.html#turboveg-data-format",
    "title": "Turboveg for R",
    "section": "1.1 Turboveg data format",
    "text": "1.1 Turboveg data format\nTurboveg for Windows is a program designed for the storage, selection, and export of vegetation plot data (relev√©s).The information is divided among several files that are matched by either species ID or releve ID. Within the Turboveg interface, you do not see this structure directly, but you can find it if you look in the Turbowin folder, subfolder data and particular database (see example below).\n\nAt some point you need to export the data and process them further. This can be done for example in a specialised software called JUICE, but also directly in R.\n\nTo get Turboveg data to R, you first need to export the Turboveg database to a folder where you want to process the data. This step requires selection of all the plots you want to export. Alternatively you can access the files directly in the main file in Turbowin, but just to warn you, if you do something wrong here, you might completely loose your data.",
    "crumbs": [
      "Data processing tutorial",
      "Turboveg to R"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/turboveg_r.html#load-libraries",
    "href": "DataProcessingTutorial/turboveg_r.html#load-libraries",
    "title": "Turboveg for R",
    "section": "1.2 Load libraries",
    "text": "1.2 Load libraries\n\nlibrary(foreign)   #for reading dbf files \nlibrary(tidyverse) #for data handling, pipes and visualisation \nlibrary(readxl)    #for data import directly from Excel \nlibrary(janitor)   #for unified, easy-to-handle format of variable names",
    "crumbs": [
      "Data processing tutorial",
      "Turboveg to R"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/turboveg_r.html#import-env-file-headers",
    "href": "DataProcessingTutorial/turboveg_r.html#import-env-file-headers",
    "title": "Turboveg for R",
    "section": "1.3 Import env file = headers",
    "text": "1.3 Import env file = headers\nOne option is to check the exported database manually, open the file called tvhabita.dbf in Excel and save it as tvhabita.xlsx or tvhabita.csv (UTF 8 encoded) file into your data folder. Although it includes one more step outside R, it is still rather straightforward and it saves you troubles with different formats in Turboveg and in R (encoding issues).\nYou can then import the file as Excel\n\nenv &lt;- read_excel(\"data/tvhabita.xlsx\")\n\nor from csv file, which is a slightly more universal option and we will use it for import of most of the files.\n\nenv &lt;- read_csv(\"data/tvhabita.csv\")\n\nRows: 137 Columns: 84\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \",\"\nchr (13): COUNTRY, COVERSCALE, AUTHOR, SYNTAXON, MOSS_IDENT, LICH_IDENT, REM...\ndbl (45): RELEVE_NR, DATE, SURF_AREA, ALTITUDE, EXPOSITION, INCLINATIO, COV_...\nlgl (26): REFERENCE, TABLE_NR, NR_IN_TAB, PROJECT, UTM, RESURVEY, FOR_EVA, R...\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nIf you check the imported names, they are rather difficult to handle.\n\nnames(env)\n\n [1] \"RELEVE_NR\"  \"COUNTRY\"    \"REFERENCE\"  \"TABLE_NR\"   \"NR_IN_TAB\" \n [6] \"COVERSCALE\" \"PROJECT\"    \"AUTHOR\"     \"DATE\"       \"SYNTAXON\"  \n[11] \"SURF_AREA\"  \"UTM\"        \"ALTITUDE\"   \"EXPOSITION\" \"INCLINATIO\"\n[16] \"COV_TOTAL\"  \"COV_TREES\"  \"COV_SHRUBS\" \"COV_HERBS\"  \"COV_MOSSES\"\n[21] \"COV_LICHEN\" \"COV_ALGAE\"  \"COV_LITTER\" \"COV_WATER\"  \"COV_ROCK\"  \n[26] \"TREE_HIGH\"  \"TREE_LOW\"   \"SHRUB_HIGH\" \"SHRUB_LOW\"  \"HERB_HIGH\" \n[31] \"HERB_LOW\"   \"HERB_MAX\"   \"CRYPT_HIGH\" \"MOSS_IDENT\" \"LICH_IDENT\"\n[36] \"REMARKS\"    \"COORD_CODE\" \"SYNTAX_OLD\" \"RESURVEY\"   \"FOR_EVA\"   \n[41] \"RS_PROJECT\" \"RS_SITE\"    \"RS_PLOT\"    \"RS_OBSERV\"  \"PLOT_SHAPE\"\n[46] \"MANIPULATE\" \"MANIPTYP\"   \"LOC_METHOD\" \"DATA_OWNER\" \"EVA_ACCESS\"\n[51] \"LONGITUDE\"  \"LATITUDE\"   \"PRECISION\"  \"LOCALITY\"   \"BIAS_MIN\"  \n[56] \"BIAS_GPS\"   \"CEBA_GRID\"  \"FIELD_NR\"   \"HABITAT\"    \"GEOLOGY\"   \n[61] \"SOIL\"       \"WATER_PH\"   \"S_PH_H2O\"   \"S_PH_KCL\"   \"S_PH_CACL2\"\n[66] \"SOIL_PH\"    \"CONDUCT\"    \"NR_ORIG\"    \"HLOUBK_CM\"  \"DNO\"       \n[71] \"CEL_PLO_M2\" \"ZAROST_PLO\" \"ESY_CODE\"   \"ESY_NAME\"   \"COV_WOOD\"  \n[76] \"SOIL_DPT\"   \"TRAMPLING\"  \"PLOT_TYPE\"  \"RS_CODE\"    \"RS_PROJTYP\"\n[81] \"RADIATION\"  \"HEAT\"       \"LES\"        \"NELES\"     \n\n\nTherefore we will directly change them to tidy names with the clean_names function from package janitor. Alternative is to rename one by one using e.g.¬†rename, but here we want to save time and effort.\n\nenv &lt;- read_csv(\"data/tvhabita.csv\")%&gt;% \n  clean_names() \n\nRows: 137 Columns: 84\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \",\"\nchr (13): COUNTRY, COVERSCALE, AUTHOR, SYNTAXON, MOSS_IDENT, LICH_IDENT, REM...\ndbl (45): RELEVE_NR, DATE, SURF_AREA, ALTITUDE, EXPOSITION, INCLINATIO, COV_...\nlgl (26): REFERENCE, TABLE_NR, NR_IN_TAB, PROJECT, UTM, RESURVEY, FOR_EVA, R...\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ntibble(env)\n\n# A tibble: 137 √ó 84\n   releve_nr country reference table_nr nr_in_tab coverscale project author\n       &lt;dbl&gt; &lt;chr&gt;   &lt;lgl&gt;     &lt;lgl&gt;    &lt;lgl&gt;     &lt;chr&gt;      &lt;lgl&gt;   &lt;chr&gt; \n 1    183111 CZ      NA        NA       NA        02         NA      0832  \n 2    183112 CZ      NA        NA       NA        02         NA      0832  \n 3    183113 CZ      NA        NA       NA        02         NA      0832  \n 4    183114 CZ      NA        NA       NA        02         NA      0832  \n 5    183115 CZ      NA        NA       NA        02         NA      0832  \n 6    183116 CZ      NA        NA       NA        02         NA      0832  \n 7    183117 CZ      NA        NA       NA        02         NA      0832  \n 8    183118 CZ      NA        NA       NA        02         NA      0832  \n 9    183119 CZ      NA        NA       NA        02         NA      0832  \n10    183120 CZ      NA        NA       NA        02         NA      0832  \n# ‚Ñπ 127 more rows\n# ‚Ñπ 76 more variables: date &lt;dbl&gt;, syntaxon &lt;chr&gt;, surf_area &lt;dbl&gt;, utm &lt;lgl&gt;,\n#   altitude &lt;dbl&gt;, exposition &lt;dbl&gt;, inclinatio &lt;dbl&gt;, cov_total &lt;dbl&gt;,\n#   cov_trees &lt;dbl&gt;, cov_shrubs &lt;dbl&gt;, cov_herbs &lt;dbl&gt;, cov_mosses &lt;dbl&gt;,\n#   cov_lichen &lt;dbl&gt;, cov_algae &lt;dbl&gt;, cov_litter &lt;dbl&gt;, cov_water &lt;dbl&gt;,\n#   cov_rock &lt;dbl&gt;, tree_high &lt;dbl&gt;, tree_low &lt;dbl&gt;, shrub_high &lt;dbl&gt;,\n#   shrub_low &lt;dbl&gt;, herb_high &lt;dbl&gt;, herb_low &lt;dbl&gt;, herb_max &lt;dbl&gt;, ‚Ä¶\n\n\nNote that the pipe %&gt;% allows the output of a previous command to be used as input to another command instead of using nested functions. It means, pipe binds individual steps into a sequence and it reads from left to right. You can insert it into your code as ctrl+shift+M.\n\nnames(env)\n\n [1] \"releve_nr\"  \"country\"    \"reference\"  \"table_nr\"   \"nr_in_tab\" \n [6] \"coverscale\" \"project\"    \"author\"     \"date\"       \"syntaxon\"  \n[11] \"surf_area\"  \"utm\"        \"altitude\"   \"exposition\" \"inclinatio\"\n[16] \"cov_total\"  \"cov_trees\"  \"cov_shrubs\" \"cov_herbs\"  \"cov_mosses\"\n[21] \"cov_lichen\" \"cov_algae\"  \"cov_litter\" \"cov_water\"  \"cov_rock\"  \n[26] \"tree_high\"  \"tree_low\"   \"shrub_high\" \"shrub_low\"  \"herb_high\" \n[31] \"herb_low\"   \"herb_max\"   \"crypt_high\" \"moss_ident\" \"lich_ident\"\n[36] \"remarks\"    \"coord_code\" \"syntax_old\" \"resurvey\"   \"for_eva\"   \n[41] \"rs_project\" \"rs_site\"    \"rs_plot\"    \"rs_observ\"  \"plot_shape\"\n[46] \"manipulate\" \"maniptyp\"   \"loc_method\" \"data_owner\" \"eva_access\"\n[51] \"longitude\"  \"latitude\"   \"precision\"  \"locality\"   \"bias_min\"  \n[56] \"bias_gps\"   \"ceba_grid\"  \"field_nr\"   \"habitat\"    \"geology\"   \n[61] \"soil\"       \"water_ph\"   \"s_ph_h2o\"   \"s_ph_kcl\"   \"s_ph_cacl2\"\n[66] \"soil_ph\"    \"conduct\"    \"nr_orig\"    \"hloubk_cm\"  \"dno\"       \n[71] \"cel_plo_m2\" \"zarost_plo\" \"esy_code\"   \"esy_name\"   \"cov_wood\"  \n[76] \"soil_dpt\"   \"trampling\"  \"plot_type\"  \"rs_code\"    \"rs_projtyp\"\n[81] \"radiation\"  \"heat\"       \"les\"        \"neles\"     \n\n\nPipe also enables me to try first what would be the output before saving the result. For example I want to select just few variables for checking, but not to overwrite the data, before I am happy with the selection. For example here I see, the habitat information is not filled (returns NAs), so I will not use it.\n\nenv %&gt;% \n  select(releve_nr, habitat, latitude, longitude)\n\n# A tibble: 137 √ó 4\n   releve_nr habitat latitude longitude\n       &lt;dbl&gt; &lt;lgl&gt;      &lt;dbl&gt;     &lt;dbl&gt;\n 1    183111 NA       492015.   163420 \n 2    183112 NA       492129.   163346.\n 3    183113 NA       492126.   162913.\n 4    183114 NA       490210.   162138.\n 5    183115 NA       490203.   162128.\n 6    183116 NA       490158.   162117.\n 7    183117 NA       490253.   162349.\n 8    183118 NA       490730.   161735.\n 9    183119 NA       490742.   161622.\n10    183120 NA       490814.   161507 \n# ‚Ñπ 127 more rows\n\n\nWhen I am fine with the selection, I can rewrite the file\n\nenv &lt;- env %&gt;% \n  select(releve_nr, coverscale,field_nr, country, author, date, syntaxon, \n         altitude, exposition, inclinatio, \n         cov_trees, cov_shrubs, cov_herbs, cov_mosses, \n         latitude, longitude, precision, bias_min, bias_gps, locality )\n\nOr I can add all the steps I did so far into one pipeline and check the resulting dataset\n\nenv &lt;- read_csv(\"data/tvhabita.csv\")%&gt;% \n  clean_names() %&gt;% \n  select(releve_nr, coverscale, field_nr, country, author, date, syntaxon, \n         altitude, exposition, inclinatio, \n         cov_trees, cov_shrubs, cov_herbs, cov_mosses, \n         latitude, longitude, precision, bias_min, bias_gps, locality ) %&gt;% \n  glimpse()\n\nRows: 137 Columns: 84\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \",\"\nchr (13): COUNTRY, COVERSCALE, AUTHOR, SYNTAXON, MOSS_IDENT, LICH_IDENT, REM...\ndbl (45): RELEVE_NR, DATE, SURF_AREA, ALTITUDE, EXPOSITION, INCLINATIO, COV_...\nlgl (26): REFERENCE, TABLE_NR, NR_IN_TAB, PROJECT, UTM, RESURVEY, FOR_EVA, R...\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nRows: 137\nColumns: 20\n$ releve_nr  &lt;dbl&gt; 183111, 183112, 183113, 183114, 183115, 183116, 183117, 183‚Ä¶\n$ coverscale &lt;chr&gt; \"02\", \"02\", \"02\", \"02\", \"02\", \"02\", \"02\", \"02\", \"02\", \"02\",‚Ä¶\n$ field_nr   &lt;chr&gt; \"2/2007\", \"3/2007\", \"4/2007\", \"5/2007\", \"6/2007\", \"7/2007\",‚Ä¶\n$ country    &lt;chr&gt; \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\",‚Ä¶\n$ author     &lt;chr&gt; \"0832\", \"0832\", \"0832\", \"0832\", \"0832\", \"0832\", \"0832\", \"08‚Ä¶\n$ date       &lt;dbl&gt; 20070702, 20070702, 20070702, 20070703, 20070703, 20070703,‚Ä¶\n$ syntaxon   &lt;chr&gt; \"LDA01\", \"LDA01\", \"LDA\", \"LDA01\", \"LDA\", \"LD\", \"LBB\", \"LB\",‚Ä¶\n$ altitude   &lt;dbl&gt; 458, 414, 379, 374, 380, 373, 390, 255, 340, 368, 356, 427,‚Ä¶\n$ exposition &lt;dbl&gt; 150, 150, 210, NA, 170, 65, NA, 80, 220, 95, 200, 170, 130,‚Ä¶\n$ inclinatio &lt;dbl&gt; 24, 13, 21, 0, 10, 6, 0, 38, 13, 29, 38, 27, 7, 22, 9, 21, ‚Ä¶\n$ cov_trees  &lt;dbl&gt; 80, 80, 75, 70, 65, 65, 85, 80, 70, 85, 45, 70, 65, 70, 80,‚Ä¶\n$ cov_shrubs &lt;dbl&gt; 0, 0, 0, 0, 1, 0, 0, 20, 0, 15, 1, 0, 2, 1, 12, 0, 0, 0, 0,‚Ä¶\n$ cov_herbs  &lt;dbl&gt; 25, 25, 30, 35, 60, 70, 70, 15, 75, 8, 75, 40, 60, 40, 60, ‚Ä¶\n$ cov_mosses &lt;dbl&gt; 10, 8, 10, 8, 3, 5, 5, 10, 3, 5, 20, 3, 5, 30, 1, 5, 1, 5, ‚Ä¶\n$ latitude   &lt;dbl&gt; 492015.3, 492128.9, 492126.4, 490210.2, 490203.1, 490158.5,‚Ä¶\n$ longitude  &lt;dbl&gt; 163420.0, 163345.8, 162913.4, 162137.8, 162128.3, 162117.2,‚Ä¶\n$ precision  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,‚Ä¶\n$ bias_min   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,‚Ä¶\n$ bias_gps   &lt;dbl&gt; 5, 6, 10, 6, 5, 6, 14, 6, 4, 5, 5, 5, 6, 6, 5, 11, 8, 7, 4,‚Ä¶\n$ locality   &lt;chr&gt; \"Svino≈°ice (Brno, Ku≈ôim); 450 m SZ od st≈ôedu obce\", \"La≈æany‚Ä¶\n\n\nAnd save it for easier access. Always keep releve_nr and coverscale, as you will need them later on.\n\nwrite.csv(env, \"data/env.csv\")\n\n*Alternative option is to directly import the file exported from Turboveg database named tvhabita.dbf using specific approach. Since dbf is a bit specific type of files and we need to use a specialised packages. Here I used read.dbf function from the foreign library.\n\nenv_dbf &lt;- read.dbf(\"data/tvhabita.dbf\", as.is = F) %&gt;%    \n  clean_names()\n\nCheck the structure, directly in R\n\nview(env_dbf)\n\nGet the list of the variable names\n\nnames(env_dbf)\n\n [1] \"releve_nr\"  \"country\"    \"reference\"  \"table_nr\"   \"nr_in_tab\" \n [6] \"coverscale\" \"project\"    \"author\"     \"date\"       \"syntaxon\"  \n[11] \"surf_area\"  \"utm\"        \"altitude\"   \"exposition\" \"inclinatio\"\n[16] \"cov_total\"  \"cov_trees\"  \"cov_shrubs\" \"cov_herbs\"  \"cov_mosses\"\n[21] \"cov_lichen\" \"cov_algae\"  \"cov_litter\" \"cov_water\"  \"cov_rock\"  \n[26] \"tree_high\"  \"tree_low\"   \"shrub_high\" \"shrub_low\"  \"herb_high\" \n[31] \"herb_low\"   \"herb_max\"   \"crypt_high\" \"moss_ident\" \"lich_ident\"\n[36] \"remarks\"    \"coord_code\" \"syntax_old\" \"resurvey\"   \"for_eva\"   \n[41] \"rs_project\" \"rs_site\"    \"rs_plot\"    \"rs_observ\"  \"plot_shape\"\n[46] \"manipulate\" \"maniptyp\"   \"loc_method\" \"data_owner\" \"eva_access\"\n[51] \"longitude\"  \"latitude\"   \"precision\"  \"locality\"   \"bias_min\"  \n[56] \"bias_gps\"   \"ceba_grid\"  \"field_nr\"   \"habitat\"    \"geology\"   \n[61] \"soil\"       \"water_ph\"   \"s_ph_h2o\"   \"s_ph_kcl\"   \"s_ph_cacl2\"\n[66] \"soil_ph\"    \"conduct\"    \"nr_orig\"    \"hloubk_cm\"  \"dno\"       \n[71] \"cel_plo_m2\" \"zarost_plo\" \"esy_code\"   \"esy_name\"   \"cov_wood\"  \n[76] \"soil_dpt\"   \"trampling\"  \"plot_type\"  \"rs_code\"    \"rs_projtyp\"\n[81] \"radiation\"  \"heat\"       \"les\"        \"neles\"     \n\n\nThere are several issues with this type of import, as there might be different encodings used in the original files, not compatible with R. For Czech dataset I needed to further change the encoding style, so that the diacritics in text columns translates correctly.\nCheck where are problems with encoding, add column names to the brackets, first we need to select the columns that include text there are issues with diacritics and special symbols, e.g.¬†remarks, locality‚Ä¶ I specify them in the brackets and use function iconv to change the encoding to UTF-8. You may need to play a bit to see if it works correctly and change the original type in the from argument. I added one more line to transform the dataframe to tibble, which is the data format used in tidyverse packages.\n\nenv_dbf %&gt;%   \n  mutate(across(c(remarks, locality, habitat, soil),\n                ~ iconv(.x, from = \"cp852\", to = \"UTF-8\"))) %&gt;%\n  select(locality, soil) %&gt;%\n  as_tibble()\n\n# A tibble: 137 √ó 2\n   locality                                                                soil \n   &lt;chr&gt;                                                                   &lt;chr&gt;\n 1 Svino≈°ice (Brno, Ku≈ôim); 450 m SZ od st≈ôedu obce                        &lt;NA&gt; \n 2 La≈æany (Brno, Ku≈ôim); 1 km VSV od st≈ôedu obce                           &lt;NA&gt; \n 3 V≈°echovice (Ti≈°nov); 500 m Z od st≈ôedu obce                             &lt;NA&gt; \n 4 Vedrovice (Moravsk√Ω Krumlov), Krumlovsk√Ω les; 2,2 km SZ od st≈ôedu obce  &lt;NA&gt; \n 5 Vedrovice (Moravsk√Ω Krumlov), Krumlovsk√Ω les; 2,1 km SZ od st≈ôedu obce  &lt;NA&gt; \n 6 Vedrovice (Moravsk√Ω Krumlov), Krumlovsk√Ω les; 2,2 km SZ od st≈ôedu obce  &lt;NA&gt; \n 7 Vedrovice (Moravsk√Ω Krumlov), Krumlovsk√Ω les; 3,3 km SSV od st≈ôedu obce &lt;NA&gt; \n 8 ƒåuƒçice (Oslavany), P≈ô√≠rodn√≠ park Oslava; 1,7 km JV od st≈ôedu obce       &lt;NA&gt; \n 9 ƒåuƒçice (Oslavany), P≈ô√≠rodn√≠ park Oslava; 1 km JJZ od st≈ôedu obce        &lt;NA&gt; \n10 Senorady (Oslavany), P≈ô√≠rodn√≠ park Oslava; 1,2 km SSV od st≈ôedu obce    &lt;NA&gt; \n# ‚Ñπ 127 more rows\n\n\nIn the next step we select variables we want to keep further, which is useful, as the database structure includes also predefined variables, even if they are empty. Another advantage of select function\n\nenv &lt;- env_dbf %&gt;%\n  mutate(across(c(remarks, locality, habitat, soil),\n                ~ iconv(.x, from = \"cp852\", to = \"UTF-8\"))) %&gt;%\n  select(releve_nr, coverscale,field_nr, country, author, date, syntaxon, \n         altitude, exposition, inclinatio, \n         cov_trees, cov_shrubs, cov_herbs, cov_mosses, \n         latitude, longitude, precision, bias_min, bias_gps, locality )%&gt;%\n  as_tibble()",
    "crumbs": [
      "Data processing tutorial",
      "Turboveg to R"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/turboveg_r.html#import-spe-file-species-file-in-a-long-format",
    "href": "DataProcessingTutorial/turboveg_r.html#import-spe-file-species-file-in-a-long-format",
    "title": "Turboveg for R",
    "section": "1.4 Import spe file = species file in a long format",
    "text": "1.4 Import spe file = species file in a long format\nFirst option is again to open the tvabund.dbf in Excel and save it as tvabund.csv. And import it to our environment in R. Again, I will use the clean_names function during import, so that we have the same style of the variable names.\n\ntvabund &lt;- read_csv(\"data/tvabund.csv\") %&gt;% \n  clean_names()\n\nRows: 4583 Columns: 5\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \",\"\nchr (1): COVER_CODE\ndbl (3): RELEVE_NR, SPECIES_NR, LAYER\nlgl (1): _ORIG_NAME\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n*Alternative option is to read the data directly from the dbf file. In this case, it is less complicated than import of env file, as there are no text variables.\n\ntvabund &lt;- read.dbf(\"data/tvabund.dbf\", as.is = F) %&gt;% \n  clean_names()\n\n\nglimpse(tvabund)\n\nRows: 4,583\nColumns: 5\n$ releve_nr  &lt;dbl&gt; 183111, 183111, 183111, 183111, 183111, 183111, 183111, 183‚Ä¶\n$ species_nr &lt;dbl&gt; 2206, 2315, 3351, 4283, 4430, 4577, 5127, 5137, 5165, 5353,‚Ä¶\n$ cover_code &lt;chr&gt; \"+\", \"1\", \"r\", \"1\", \"r\", \"r\", \"1\", \"+\", \"r\", \"r\", \"2b\", \"+\"‚Ä¶\n$ layer      &lt;dbl&gt; 6, 7, 6, 6, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 7, 6, 6, 6, 6,‚Ä¶\n$ orig_name  &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,‚Ä¶\n\n\nNow we will check the data again and we see, that there are no species names, just numbers. Also the cover is given in the original codes and not in percentages. See the scheme below to understand where each piece of the information is stored.\n\nWe have to prepare these different files we need, import them and merge them.\n\n1.4.1 Nomenclature\nIn the abund file, species numbers refer to the codes in the checklist used in the Turboveg database. To translate them into species names you will need a translation table with the original number in the database, original name in the database and the name you want to use in the analyses.\n\nPreparation of translation table: To show you how to prepare such a table I opened the checklist file, so called species.dbf from the folder: Turbowin/species/CzechiaSlovakia2015 and saved it here in the data folder as species.csv Using the following pipeline you can prepare your own translation table and add other names or information.\n\nnomenclature_raw &lt;- read_csv(\"data/species.csv\") %&gt;%   \n  clean_names() %&gt;%   \n  left_join(select(., species_nr, accepted_abbreviat = abbreviat),     \n            by = c(\"valid_nr\" = \"species_nr\")) %&gt;%   \n  mutate(accepted_name = if_else(synonym, accepted_abbreviat, abbreviat)) %&gt;%\n  select(-accepted_abbreviat) \n\nRows: 13863 Columns: 6\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \",\"\nchr (3): LETTERCODE, SHORTNAME, ABBREVIAT\ndbl (2): SPECIES_NR, VALID_NR\nlgl (1): SYNONYM\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nWe will now import the nomenclature file that is already adapted for Czech flora.\n\nnomenclature &lt;- read_csv(\"data/nomenclature_20251108.csv\") %&gt;%\n  clean_names()  \n\nRows: 13862 Columns: 7\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \",\"\nchr (4): LETTERCODE, TurbovegCzechiaSlovakia, Kaplan, ExpertSystem\ndbl (2): SPECIES_NR, nonvascular\nlgl (1): SYNONYM\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ntibble(nomenclature)\n\n# A tibble: 13,862 √ó 7\n   species_nr lettercode synonym turboveg_czechia_slovakia  kaplan expert_system\n        &lt;dbl&gt; &lt;chr&gt;      &lt;lgl&gt;   &lt;chr&gt;                      &lt;chr&gt;  &lt;chr&gt;        \n 1      14321 *CONC*C    FALSE   x Conygeron huelsenii      x Con‚Ä¶ x Conyzigero‚Ä¶\n 2      14323 *DACD*A    FALSE   x Dactylodenia gracilis    x Dac‚Ä¶ x Dactylogym‚Ä¶\n 3      14324 *DACD*A    TRUE    x Dactylodenia st.-quinti‚Ä¶ x Dac‚Ä¶ x Dactylogym‚Ä¶\n 4      14322 *DACD*D    FALSE   x Dactylodenia comigera    x Dac‚Ä¶ x Dactylogym‚Ä¶\n 5      14325 *DATD*D    FALSE   x Dactyloglossum erdingeri x Dac‚Ä¶ x Dactyloglo‚Ä¶\n 6      14327 *FESF*E    FALSE   x Festulolium loliaceum    x Fes‚Ä¶ x Festuloliu‚Ä¶\n 7      14326 *FESF*F    FALSE   x Festulolium braunii      x Fes‚Ä¶ x Festuloliu‚Ä¶\n 8      14328 *GYMG*G    FALSE   x Gymnanacamptis anacampt‚Ä¶ x Gym‚Ä¶ x Gymnanacam‚Ä¶\n 9      14329 *ORCO*O    FALSE   x Orchidactyla boudieri    x Dac‚Ä¶ x Dactylocam‚Ä¶\n10      14330 *PSEP*P    FALSE   x Pseudadenia schweinfurt‚Ä¶ x Pse‚Ä¶ x Pseudadeni‚Ä¶\n# ‚Ñπ 13,852 more rows\n# ‚Ñπ 1 more variable: nonvascular &lt;dbl&gt;\n\n\nThere are several advantages about this approach. First, you can adjust the nomenclature to the newest source/regional checklist etc. In our example the name in Turboveg is translated to the nomenclature presented in the recent Key of the Czech Flora, and it is named after the main editor Kaplan.\nSecond, I can add a concept that groups several taxa into higher units, e.g.¬†taxa that are not easy to recognise in the field are assigned into aggregates. This is exactly the same approach as you do when you create an expert system file. Here it is even more easy to understand and much easier to change the translation when you need to fix something. The name in this file is called ESy.\nLast but not least. I can directly add much more information into such table. For example status, growth form or anything else. Here we have indication if the species is nonvascular.\nI might want to check how the species are translated with the use of my translation file and select just these matching rows. Either create a variable called selection indicating if the species is in the subset or not\n\nnomenclature_check&lt;- nomenclature %&gt;% \n  left_join(tvabund %&gt;% \n              distinct(species_nr)%&gt;%\n              mutate(selection=1)) \n\nJoining with `by = join_by(species_nr)`\n\n\nor I can even add the frequency, how many times it appears in the records of the dataset\n\nnomenclature_check&lt;- nomenclature %&gt;% \n  left_join(tvabund %&gt;% \n              count(species_nr)) \n\nJoining with `by = join_by(species_nr)`\n\n\nI can then write the file, make adjustments e.g.¬†in Excel and upload it newly. Great thing is that I have indication of which species are in the dataset and I do not have to pay attention to the other rows.\n\nwrite.csv(nomenclature_check, \"data/nomenclature_check.csv\")\n\nupload the new, adjusted file\n\nnomenclature &lt;- read_csv(\"data/nomenclature_check.csv\") %&gt;%\n  clean_names()  \n\n\n\n1.4.2 Cover\nWe have translation table for nomenclature, but we still need to translate cover codes to percentages. For cover translation we need to use information about cover scale (stored in the header data / tvhabita / env file) and information how to translate the values in that particular scale to percentages. The file here was prepared based on the translation of cover values in different scales to percentages following the EVA database approach. One more column was added to enable different adjustments, for example change the values for rare species etc. For any project I suggest to open the file and check if the scales you are using are there and if you agree with the translation.\n\ncover &lt;- read_csv(\"data/cover_20230402.csv\") %&gt;% clean_names()  \n\nRows: 326 Columns: 6\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDelimiter: \",\"\nchr (3): CoverScaleName, COVERSCALE, COVER_CODE\ndbl (3): ID, CoverPercEVA, CoverPerc\n\n‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ntibble(cover)\n\n# A tibble: 326 √ó 6\n      id cover_scale_name coverscale cover_code cover_perc_eva cover_perc\n   &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;      &lt;chr&gt;               &lt;dbl&gt;      &lt;dbl&gt;\n 1     1 Percetage %      00         0.1                   0.1        0.1\n 2     2 Percetage %      00         0.2                   0.2        0.2\n 3     3 Percetage %      00         0.3                   0.3        0.3\n 4     4 Percetage %      00         0.4                   0.4        0.4\n 5     5 Percetage %      00         0.5                   0.5        0.5\n 6     6 Percetage %      00         0.6                   0.6        0.6\n 7     7 Percetage %      00         0.7                   0.7        0.7\n 8     8 Percetage %      00         0.8                   0.8        0.8\n 9     9 Percetage %      00         0.9                   0.9        0.9\n10    10 Percetage %      00         1                     1          1  \n# ‚Ñπ 316 more rows\n\n\nThe file here was prepared based on the translation of cover values in different scales to percentages following the EVA database approach. One more column was added to enable different adjustments, for example change the values for rare species etc. For any project I suggest to open the file and check if the scales you are using are there and if you agree with the translation.\nHere I can check the different scale names included in the file\n\ncover %&gt;% distinct(cover_scale_name) \n\n# A tibble: 16 √ó 1\n   cover_scale_name      \n   &lt;chr&gt;                 \n 1 Percetage %           \n 2 Braun/Blanquet (old)  \n 3 Braun/Blanquet (new)  \n 4 Londo                 \n 5 Presence/Absence      \n 6 Ordinale scale (1-9)  \n 7 Barkman, Doing & Segal\n 8 Doing                 \n 9 Domin                 \n10 Sedlakova             \n11 ZlatnÀák               \n12 Percentual scale      \n13 Hedl                  \n14 Ku≈∫era                \n15 Domin (uprava Hadac)  \n16 Percentual (r, +)     \n\n\nAnd I can also filter the rows of the specified scales. E.g. here I am looking for all those that start with a specific pattern ‚ÄúBraun‚Äù\n\ncover %&gt;% \n  filter(str_starts(cover_scale_name, \"Braun\")) %&gt;% \n  print(n=20)\n\n# A tibble: 16 √ó 6\n      id cover_scale_name     coverscale cover_code cover_perc_eva cover_perc\n   &lt;dbl&gt; &lt;chr&gt;                &lt;chr&gt;      &lt;chr&gt;               &lt;dbl&gt;      &lt;dbl&gt;\n 1   110 Braun/Blanquet (old) 01         r                       1        1  \n 2   111 Braun/Blanquet (old) 01         +                       2        2  \n 3   112 Braun/Blanquet (old) 01         1                       3        3  \n 4   113 Braun/Blanquet (old) 01         2                      13       13  \n 5   114 Braun/Blanquet (old) 01         3                      38       38  \n 6   115 Braun/Blanquet (old) 01         4                      63       63  \n 7   116 Braun/Blanquet (old) 01         5                      88       88  \n 8   117 Braun/Blanquet (new) 02         r                       1        0.1\n 9   118 Braun/Blanquet (new) 02         +                       2        0.5\n10   119 Braun/Blanquet (new) 02         1                       3        3  \n11   120 Braun/Blanquet (new) 02         2m                      4        4  \n12   121 Braun/Blanquet (new) 02         2a                      8       10  \n13   122 Braun/Blanquet (new) 02         2b                     18       20  \n14   123 Braun/Blanquet (new) 02         3                      38       37.5\n15   124 Braun/Blanquet (new) 02         4                      63       62.5\n16   125 Braun/Blanquet (new) 02         5                      88       87.5\n\n\n\n\n1.4.2 Merging all files together into complete spe file\nFinally, I have translation to nomenclature, to cover, so I need to put everything together.\n\ntvabund %&gt;% \n  left_join(nomenclature %&gt;% \n              select(species_nr, kaplan, expert_system, nonvascular)) %&gt;% \n  left_join(env %&gt;% select(releve_nr, coverscale)) %&gt;% \n  left_join(cover %&gt;% select(coverscale,cover_code,cover_perc))\n\nJoining with `by = join_by(species_nr)`\nJoining with `by = join_by(releve_nr)`\nJoining with `by = join_by(cover_code, coverscale)`\n\n\n# A tibble: 4,583 √ó 10\n   releve_nr species_nr cover_code layer orig_name kaplan          expert_system\n       &lt;dbl&gt;      &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;lgl&gt;     &lt;chr&gt;           &lt;chr&gt;        \n 1    183111       2206 +              6 NA        Carex digitata‚Ä¶ Carex digita‚Ä¶\n 2    183111       2315 1              7 NA        Carpinus betul‚Ä¶ Carpinus bet‚Ä¶\n 3    183111       3351 r              6 NA        Cytisus nigric‚Ä¶ Cytisus nigr‚Ä¶\n 4    183111       4283 1              6 NA        Festuca ovina   Festuca ovina\n 5    183111       4430 r              7 NA        Fraxinus excel‚Ä¶ Fraxinus exc‚Ä¶\n 6    183111       4577 r              6 NA        Galium rotundi‚Ä¶ Galium rotun‚Ä¶\n 7    183111       5127 1              6 NA        Hieracium lach‚Ä¶ Hieracium la‚Ä¶\n 8    183111       5137 +              6 NA        Hieracium muro‚Ä¶ Hieracium mu‚Ä¶\n 9    183111       5165 r              6 NA        Hieracium saba‚Ä¶ Hieracium sa‚Ä¶\n10    183111       5353 r              6 NA        Hypericum perf‚Ä¶ Hypericum pe‚Ä¶\n# ‚Ñπ 4,573 more rows\n# ‚Ñπ 3 more variables: nonvascular &lt;dbl&gt;, coverscale &lt;chr&gt;, cover_perc &lt;dbl&gt;\n\n\nThe output contains these variables\n \"releve_nr\"     \"species_nr\"    \"cover_code\"    \"layer\"         \"orig_name\"     \"kaplan\"        \"expert_system\" \"nonvascular\"   \"coverscale\"    \"cover_perc\"   \nIf I am satisfied with the result I assign the pipeline into the spe file and add one more line to select just needed variables, here I decided to use just the expert_system name and I renamed it directly in the select function\n\nspe&lt;- tvabund %&gt;% \n  left_join(nomenclature %&gt;% \n              select(species_nr, kaplan, expert_system, nonvascular)) %&gt;% \n  left_join(env %&gt;% select(releve_nr, coverscale)) %&gt;% \n  left_join(cover %&gt;% select(coverscale,cover_code,cover_perc)) %&gt;%\n  # filter (!nonvascular=1) %&gt;% # optional to remove nonvasculars\n  select(releve_nr, species= expert_system, nonvascular, layer, cover_perc)\n\nJoining with `by = join_by(species_nr)`\nJoining with `by = join_by(releve_nr)`\nJoining with `by = join_by(cover_code, coverscale)`\n\n\nTo see the result we will use view\n\nview(spe)\n\nWe can again save the final file, to be easily accessible for later\n\nwrite.csv(spe, \"data/spe.csv\")",
    "crumbs": [
      "Data processing tutorial",
      "Turboveg to R"
    ]
  }
]