[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Czech Vegetation Database",
    "section": "",
    "text": "1. Introduction\nThe Czech Vegetation Database (formerly the Czech National Phytosociological Database) is an open digital archive of vegetation-plot records from the territory of the Czech Republic. It includes phytosociological relevÃ©s, i.e., records of plant species composition and cover-abundances in delimited plots within relatively homogeneous vegetation patches, as well as similar vegetation-plot data from vegetation surveys, monitoring programs, and ecological studies.\nThe database is registered in the Global Index of Vegetation-Plot Databases (GIVD, Dengler et al.Â 2011) with the code EU-CZ-001. It is a member of the European Vegetation Archive (EVA, ChytrÃ½ et al.Â 2016), its subset of resurveyed vegetation plots (ReSurveyEurope, KnollovÃ¡ et al.Â 2024), and sPlot â€“ the Global Vegetation Database (sPlot, Bruelheide et al.Â 2019).\nIt is coordinated at the Vegetation Science Group, Department of Botany and Zoology, Faculty of Science, Masaryk University, Brno, Czech Republic. The current database administrator is Ilona KnollovÃ¡ (ikuzel@sci.muni.cz).\nIn November 2025, the database contained 116,314 vegetation plots from the Czech Republic, sampled between 1922 and 2025. These plots represent all vegetation types found in the country, with grassland and forest plots being the most numerous, followed by plots from wetlands, ruderal, and weed vegetation.\n\n\n2. Online Viewer\nhttps://vegscibrno.shinyapps.io/CzechVegetationDatabase\nThis interactive viewer of the Czech Vegetation Database provides maps and summary characteristics of vegetation plots for the whole database and its subsets defined by plot size and location uncertainty, years of sampling, altitude, covers of vegetation layers, and occurrence of specific species or species groups.\n\n\n\n3. Related resources\nEVA-MAP: www.evamap.eu\nAn interactive online viewer for the European Vegetation Archive, which includes the data from the Czech Vegetation Database. It has partly overlapping and partly unique functions.\nPhytosociological Bibliography of the Czech Republic: www.sci.muni.cz/botany/tvref\nThis online database contains the full bibliographic references to the sources of vegetation-plot data that have been digitized and included in the Cyech Vegetation Database.\n\n\n4. Website funding and authors\nThis website was launched in January 2026. Its development was supported through the Open Science Clustersâ€™ Action for Research and Society (OSCARS) Horizon Europe project under grant agreement No.Â 101129751, subproject â€œEVA-FAIR - Implementing FAIR principles in the European Vegetation Archive dataâ€.\n\nWeb design: Irena AxmanovÃ¡ and KlÃ¡ra FriesovÃ¡\nData preparation: Ilona KnollovÃ¡, with contributions from Marcela Å˜eznÃ­ÄkovÃ¡, Irena AxmanovÃ¡, Martin VeÄeÅ™a, and Milan ChytrÃ½\nStratified version of the database: Jan DivÃ­Å¡ek and Martin VeÄeÅ™a\nOnline viewer: KlÃ¡ra FriesovÃ¡\nIntroductory text and data description: Milan ChytrÃ½, with contributions from Ilona KnollovÃ¡\nData processing tutorial: Irena AxmanovÃ¡\nProject coordination: Milan ChytrÃ½",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/basic_analyses.html",
    "href": "DataProcessingTutorial/basic_analyses.html",
    "title": "Basic data analyses",
    "section": "",
    "text": "In this tutorial we will show you how to sort and filter the data. We will also train how to append traits, indicator values or information about status of species and calculate proportions of selected plant groups, community weighted and unweighted means or other summary statistics. If you are interested in more general overview of the functions, you are encouraged to check also our study materials here.\nlibrary(tidyverse)\nlibrary(janitor)",
    "crumbs": [
      "Data processing tutorial",
      "Basic data analyses"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/basic_analyses.html#data-import",
    "href": "DataProcessingTutorial/basic_analyses.html#data-import",
    "title": "Basic data analyses",
    "section": "2.1 Data import",
    "text": "2.1 Data import\nWe will play a bit with measured variables from our plots and try few useful functions. For more see study materials and links there. We will first read the data newly, to be sure we know what we are working with. At this point we can actually clean the environment, remove everything.\n\n2.1.1 env dataset\nFirst I want to add some more variables that were measured separately. In addition this file is already filtered to a subset I want to use.\n\nenv_extra&lt;- read_csv(\"data/axmanova_forest_env_extra.csv\")%&gt;%      \n  clean_names()\n\nRows: 65 Columns: 22\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr  (1): ForestTypeName\ndbl (21): Releve_nr, ForestType, Herbs, Juveniles, CoverE1, Biomass, Soil_de...\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nForÂ env datasetÂ I want to import the clean version which was saved in the previous script, but I will directly filter it to the same subset as in the dataset above. I can do it with semi_join. But I decided to merge both datasets at this point - to keep only the matching rows but all information I want. For more on joins see here.\n\nenv&lt;- read_csv(\"data/env.csv\") %&gt;%       \n  inner_join(env_extra %&gt;%                                 \n               select (releve_nr, forest_type, forest_type_name,                                                soil_ph=p_h_k_cl, biomass)%&gt;%                           \n               unite(forest, forest_type, forest_type_name))\n\nNew names:\nRows: 137 Columns: 21\nâ”€â”€ Column specification\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Delimiter: \",\" chr\n(6): coverscale, field_nr, country, author, syntaxon, locality dbl (15): ...1,\nreleve_nr, date, altitude, exposition, inclinatio, cov_trees...\nâ„¹ Use `spec()` to retrieve the full column specification for this data. â„¹\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\nJoining with `by = join_by(releve_nr)`\nâ€¢ `` -&gt; `...1`\n\n\n\n\n2.1.2 spe dataset\nI want to work with theÂ spe dataset, and I want to keep information about layers, as I want to focus on the herb-layer.\n\nspe &lt;- read_csv (\"data/spe_merged_covers.csv\")%&gt;%    \n  semi_join(env)\n\nRows: 4581 Columns: 4\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (1): species\ndbl (3): releve_nr, layer, cover_perc\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nJoining with `by = join_by(releve_nr)`\n\n\n\n\n2.1.3 traits\nI also want to add some information about traits. So I will check what is available in my folder.\n\nlist.files(\"data\")\n\n [1] \"axmanova_forest_env_extra.csv\"       \"cover_20230402.csv\"                 \n [3] \"CzechVeg_tutorial.zip\"               \"data.zip\"                           \n [5] \"env.csv\"                             \"indicator_values.csv\"               \n [7] \"nomenclature_20251108.csv\"           \"nomenclature_check.csv\"             \n [9] \"plant_height.csv\"                    \"readme.txt\"                         \n[11] \"remarks.cdx\"                         \"remarks.dbf\"                        \n[13] \"spe.csv\"                             \"spe_merged_covers.csv\"              \n[15] \"spe_merged_covers_across_layers.csv\" \"species.csv\"                        \n[17] \"status.csv\"                          \"traits.csv\"                         \n[19] \"tvabund.cdx\"                         \"tvabund.csv\"                        \n[21] \"tvabund.dbf\"                         \"tvabund.xlsx\"                       \n[23] \"TvAdmin.cdx\"                         \"TvAdmin.dbf\"                        \n[25] \"tvhabita.cdx\"                        \"tvhabita.csv\"                       \n[27] \"tvhabita.dbf\"                        \"tvhabita.xlsx\"                      \n[29] \"tvwin.dbf\"                          \n\n\nI will import plant height data, Ellenberg-type indicator values and status (origin and Red List categories). All these data are available in the PLADIAS database of the Czech flora and vegetation. I used the datasets from the download section and adjusted the format for easier data handling.\n\nplant_height&lt;- read_csv(\"data/plant_height.csv\")\n\nRows: 3258 Columns: 4\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (1): species\ndbl (3): height_min, height_max, height_mean\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nindicator_values &lt;- read_csv(\"data/indicator_values.csv\")\n\nRows: 3076 Columns: 7\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (1): species\ndbl (6): eiv_light, eiv_temperature, eiv_moisture, eiv_reaction, eiv_nutrien...\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nstatus &lt;- read_csv(\"data/status.csv\")\n\nRows: 5752 Columns: 3\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (3): species, origin, redlist\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "Data processing tutorial",
      "Basic data analyses"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/basic_analyses.html#basic-data-handling",
    "href": "DataProcessingTutorial/basic_analyses.html#basic-data-handling",
    "title": "Basic data analyses",
    "section": "2.2 Basic data handling",
    "text": "2.2 Basic data handling\nSelect extracts columns/variables based on their names or position. Select can be also used in combination with stringr package to identify the pattern in the names: try several options: starts_with, ends_with or more general one contains. With the use of select in your script you can order the variables always in the same way e.g.Â ID, forest type, species number, productivity, even during import. And you can also rename the variables using select, to get exactly what you need.\n\nenv_extra %&gt;% \n  select(ID=releve_nr, forest_type=forest_type_name, species_nr=herbs, productivity=biomass) \n\n# A tibble: 65 Ã— 4\n      ID forest_type         species_nr productivity\n   &lt;dbl&gt; &lt;chr&gt;                    &lt;dbl&gt;        &lt;dbl&gt;\n 1     1 oak hornbeam forest         26         12.8\n 2     2 oak forest                  13          9.9\n 3     3 oak forest                  14         15.2\n 4     4 oak forest                  15         16  \n 5     5 oak forest                  13         20.7\n 6     6 oak forest                  16         46.4\n 7     7 oak forest                  17         49.2\n 8     8 oak hornbeam forest         21         48.7\n 9     9 oak hornbeam forest         15         13.8\n10    10 oak forest                  14         79.1\n# â„¹ 55 more rows\n\n\nDistinct is a function that takes your data and remove all the duplicate rows, keeping only the unique ones. There are many cases where you will really appreciate this elegant and easy way. For example, I want a list of unique PlotIDs= releve_nr, unique combinations of two categories etc. Here I want to prepare list of forest types codes and names.\n\nenv_extra %&gt;%\n  arrange(forest_type) %&gt;%\n  distinct(forest_type,forest_type_name)\n\n# A tibble: 4 Ã— 2\n  forest_type forest_type_name   \n        &lt;dbl&gt; &lt;chr&gt;              \n1           1 oak forest         \n2           2 oak hornbeam forest\n3           3 ravine forest      \n4           4 alluvial forest    \n\n\nWhen we have a large dataset, we sometimes need to create a subset of the rows/cases by filter. First we have to define upon which variable we are going to filter the rows (e.g.Â Forest type, soil pHâ€¦) and which values are acceptable and which are not. Here I keep only plots from a type that exactly match.\n\nenv_extra %&gt;% \n  filter(forest_type_name ==\"alluvial forest\")\n\n# A tibble: 11 Ã— 22\n   releve_nr forest_type forest_type_name herbs juveniles cover_e1 biomass\n       &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;\n 1       101           4 alluvial forest     28         6       90    91.1\n 2       103           4 alluvial forest     35         5       80   114. \n 3       104           4 alluvial forest     25        11       85   188. \n 4       110           4 alluvial forest     37         4       95   126. \n 5       111           4 alluvial forest     26        10       85    84.8\n 6       113           4 alluvial forest     37        10       70    74.5\n 7       125           4 alluvial forest     25         8       95   123. \n 8       127           4 alluvial forest     53         6        0   176  \n 9       129           4 alluvial forest     31         7       85   100. \n10       131           4 alluvial forest     59         3       95   163. \n11       132           4 alluvial forest     60         7       90   287. \n# â„¹ 15 more variables: soil_depth_categ &lt;dbl&gt;, p_h_k_cl &lt;dbl&gt;, slope &lt;dbl&gt;,\n#   altitude &lt;dbl&gt;, canopy_e3 &lt;dbl&gt;, radiation &lt;dbl&gt;, heat &lt;dbl&gt;,\n#   trans_dir &lt;dbl&gt;, trans_dif &lt;dbl&gt;, trans_tot &lt;dbl&gt;, eiv_light &lt;dbl&gt;,\n#   eiv_moisture &lt;dbl&gt;, eiv_soilreaction &lt;dbl&gt;, eiv_nutrients &lt;dbl&gt;, twi &lt;dbl&gt;\n\n\nor those that are listed\n\nenv_extra %&gt;% \n  filter(forest_type_name %in% c(\"alluvial forest\", \"ravine forest\"))\n\n# A tibble: 21 Ã— 22\n   releve_nr forest_type forest_type_name herbs juveniles cover_e1 biomass\n       &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;\n 1       101           4 alluvial forest     28         6       90    91.1\n 2       103           4 alluvial forest     35         5       80   114. \n 3       104           4 alluvial forest     25        11       85   188. \n 4       105           3 ravine forest       12        10       80    65.5\n 5       106           3 ravine forest       16         0       75    33.6\n 6       108           3 ravine forest       28         7       70    82.3\n 7       110           4 alluvial forest     37         4       95   126. \n 8       111           4 alluvial forest     26        10       85    84.8\n 9       113           4 alluvial forest     37        10       70    74.5\n10       114           3 ravine forest       12         6       50    71.5\n# â„¹ 11 more rows\n# â„¹ 15 more variables: soil_depth_categ &lt;dbl&gt;, p_h_k_cl &lt;dbl&gt;, slope &lt;dbl&gt;,\n#   altitude &lt;dbl&gt;, canopy_e3 &lt;dbl&gt;, radiation &lt;dbl&gt;, heat &lt;dbl&gt;,\n#   trans_dir &lt;dbl&gt;, trans_dif &lt;dbl&gt;, trans_tot &lt;dbl&gt;, eiv_light &lt;dbl&gt;,\n#   eiv_moisture &lt;dbl&gt;, eiv_soilreaction &lt;dbl&gt;, eiv_nutrients &lt;dbl&gt;, twi &lt;dbl&gt;\n\n\nOr I want to filter based on some values. If I have at the same time NAs in the variable, I should specify if I want to keep these rows or not. In the example below I will keep all rows/plots where biomass is higher than 80g/m2 but I will also keep all the NAs, i.e.Â plots where it was not measured.\n\nenv_extra %&gt;% \n  filter(biomass&gt;80 |is.na(biomass))\n\n# A tibble: 17 Ã— 22\n   releve_nr forest_type forest_type_name    herbs juveniles cover_e1 biomass\n       &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;               &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;\n 1       101           4 alluvial forest        28         6       90    91.1\n 2       103           4 alluvial forest        35         5       80   114. \n 3       104           4 alluvial forest        25        11       85   188. \n 4       108           3 ravine forest          28         7       70    82.3\n 5       110           4 alluvial forest        37         4       95   126. \n 6       111           4 alluvial forest        26        10       85    84.8\n 7       120           2 oak hornbeam forest    36         6       75    98.5\n 8       121           2 oak hornbeam forest    30        12       80    84.7\n 9       122           3 ravine forest          29         6       60   102. \n10       124           2 oak hornbeam forest    34        15       75   102. \n11       125           4 alluvial forest        25         8       95   123. \n12       127           4 alluvial forest        53         6        0   176  \n13       128           3 ravine forest          20         4       70   121. \n14       129           4 alluvial forest        31         7       85   100. \n15       130           3 ravine forest          18         5       85   238  \n16       131           4 alluvial forest        59         3       95   163. \n17       132           4 alluvial forest        60         7       90   287. \n# â„¹ 15 more variables: soil_depth_categ &lt;dbl&gt;, p_h_k_cl &lt;dbl&gt;, slope &lt;dbl&gt;,\n#   altitude &lt;dbl&gt;, canopy_e3 &lt;dbl&gt;, radiation &lt;dbl&gt;, heat &lt;dbl&gt;,\n#   trans_dir &lt;dbl&gt;, trans_dif &lt;dbl&gt;, trans_tot &lt;dbl&gt;, eiv_light &lt;dbl&gt;,\n#   eiv_moisture &lt;dbl&gt;, eiv_soilreaction &lt;dbl&gt;, eiv_nutrients &lt;dbl&gt;, twi &lt;dbl&gt;\n\n\nYou can also filter plots in a specified range of some value.\n\nenv_extra %&gt;% \n  filter((biomass &gt;= 40 & biomass &lt;= 80) | is.na(biomass))\n\n# A tibble: 20 Ã— 22\n   releve_nr forest_type forest_type_name    herbs juveniles cover_e1 biomass\n       &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;               &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;\n 1         6           1 oak forest             16         3       60    46.4\n 2         7           1 oak forest             17         5       70    49.2\n 3         8           2 oak hornbeam forest    21         1       70    48.7\n 4        10           1 oak forest             14         4       75    79.1\n 5        18           2 oak hornbeam forest    13         3       85    72.2\n 6        86           2 oak hornbeam forest    32         5       40    46.9\n 7        87           2 oak hornbeam forest    34         9       65    42.9\n 8        99           2 oak hornbeam forest    18         6       85    64.8\n 9       102           2 oak hornbeam forest    37        13       65    57.4\n10       105           3 ravine forest          12        10       80    65.5\n11       109           2 oak hornbeam forest    25         9       50    60.7\n12       112           2 oak hornbeam forest    32        14       60    58.4\n13       113           4 alluvial forest        37        10       70    74.5\n14       114           3 ravine forest          12         6       50    71.5\n15       115           3 ravine forest          23         2       70    54.6\n16       116           3 ravine forest          16         3       45    64.5\n17       117           2 oak hornbeam forest    31         7       55    54.7\n18       118           2 oak hornbeam forest     8         5       45    66.2\n19       123           3 ravine forest          34        11       70    53.6\n20       126           2 oak hornbeam forest    27         7       65    72.9\n# â„¹ 15 more variables: soil_depth_categ &lt;dbl&gt;, p_h_k_cl &lt;dbl&gt;, slope &lt;dbl&gt;,\n#   altitude &lt;dbl&gt;, canopy_e3 &lt;dbl&gt;, radiation &lt;dbl&gt;, heat &lt;dbl&gt;,\n#   trans_dir &lt;dbl&gt;, trans_dif &lt;dbl&gt;, trans_tot &lt;dbl&gt;, eiv_light &lt;dbl&gt;,\n#   eiv_moisture &lt;dbl&gt;, eiv_soilreaction &lt;dbl&gt;, eiv_nutrients &lt;dbl&gt;, twi &lt;dbl&gt;\n\n\nSimilarly, you can for example filter plots based on their plot size. The example below is not working on our dataset, but it comes useful in large EVA exports. Here I keep grassland plots in the range 10-100 m2, forest plots between 100-1000 m2 and I keep the plots without specified plot size.\n\nenv %&gt;% \n  filter(\n    (habitat == \"grassland\" & plot_size &gt;= 10 & plot_size &lt;= 100) |\n    (habitat == \"forest\" & plot_size &gt;= 100 & plot_size &lt;= 1000) |\n    is.na(plot_size)\n  )",
    "crumbs": [
      "Data processing tutorial",
      "Basic data analyses"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/basic_analyses.html#summarise",
    "href": "DataProcessingTutorial/basic_analyses.html#summarise",
    "title": "Basic data analyses",
    "section": "2.3 Summarise",
    "text": "2.3 Summarise\nI will a bit explore the data and ask about which factors influence species richness. Here are just few examples, we will read together the scripts and you will adopt them later to other tasks. First I want to produce a table with summary statistics like min, mean, max for two variables plant height, and biomass per forest type. The first one is a trait, so we need to append it to species file and calculate community means, while the other is a variable measured in each plot.\nCombine and summarise different variables / explanation will be added\n\nspe %&gt;% \n  filter(layer == \"6\") %&gt;%\n  left_join(plant_height %&gt;% \n              select(species, height = height_mean)) %&gt;%\n  left_join(env) %&gt;%\n  arrange(forest) %&gt;%\n  summarise(across(c(height,cov_herbs, biomass, cov_trees,soil_ph ),\n      list(\n        min  = ~min(.x, na.rm = TRUE),\n        mean = ~mean(.x, na.rm = TRUE),\n        max  = ~max(.x, na.rm = TRUE))),.by = forest)\n\nJoining with `by = join_by(species)`\nJoining with `by = join_by(releve_nr)`\n\n\n# A tibble: 4 Ã— 16\n  forest          height_min height_mean height_max cov_herbs_min cov_herbs_mean\n  &lt;chr&gt;                &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;         &lt;dbl&gt;          &lt;dbl&gt;\n1 1_oak forest         0.075       0.495       1.45             8           37.2\n2 2_oak hornbeamâ€¦      0.055       0.497      15                7           55.6\n3 3_ravine forest      0.085       0.505       1.45            45           67.8\n4 4_alluvial forâ€¦      0.055       0.707       8.5              0           76.2\n# â„¹ 10 more variables: cov_herbs_max &lt;dbl&gt;, biomass_min &lt;dbl&gt;,\n#   biomass_mean &lt;dbl&gt;, biomass_max &lt;dbl&gt;, cov_trees_min &lt;dbl&gt;,\n#   cov_trees_mean &lt;dbl&gt;, cov_trees_max &lt;dbl&gt;, soil_ph_min &lt;dbl&gt;,\n#   soil_ph_mean &lt;dbl&gt;, soil_ph_max &lt;dbl&gt;\n\n\n\nenv %&gt;%\n  arrange(forest) %&gt;%\n  select(forest, cover_herbs=cov_herbs, biomass, cover_trees =cov_trees, soil_ph) %&gt;%\n  tidyr::pivot_longer(\n    cols = c(cover_herbs, biomass, cover_trees, soil_ph),\n    names_to = \"variable\",\n    values_to = \"value\")%&gt;% \n  ggplot(aes(x = forest, y = value, fill=forest)) +\n  geom_boxplot() +\n  facet_wrap(~ variable, scales = \"free_y\") +\n  theme_bw() +\n  theme(legend.position = 'none')+\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))+\n  labs(x = NULL) +\n  labs (y = NULL)\n\n\n\n\n\n\n\n\nI might be interested inÂ species richness relationshipÂ with several factors. Below is an example of herb-layer species richness and biomass. At first I need to calculate the species richness in the spe file. And as an output I want to plot this with different colours for different forest types but keep the regression line for the whole dataset.\n\nspe %&gt;% \n  filter(layer %in% c(6, 7)) %&gt;% \n  count(releve_nr, name = \"herblayer_richness\") %&gt;% \n  left_join(env %&gt;% \n              select(releve_nr, biomass, forest), by = \"releve_nr\") %&gt;% \n  ggplot(aes(x = sqrt(biomass), y = herblayer_richness)) +\n  geom_point(aes(colour = forest), size = 2, alpha = 0.8) +\n  geom_smooth(method = \"lm\", se = TRUE, colour = \"black\") +\n  theme_bw() +\n  labs(\n    x = \"sqrt Biomass\",\n    y = \"Herb-layer species richness\",\n    colour = \"Forest type\"\n  )\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nProportions of endangered or alien speciesÂ in forest type. I will first look at the numbers of these species, here on example of redlist i.e.Â endangered species. I just one to see average number of redlist species per forest type.\n\nspe%&gt;% \n  left_join(spe %&gt;% \n              left_join(status)%&gt;% \n              filter(!is.na(redlist))%&gt;%\n              count(releve_nr, name=\"richness_redlist\"))%&gt;%\n  left_join(spe %&gt;% \n              summarise(richness_all = n_distinct(species), \n                        .by = releve_nr))%&gt;%\n  distinct(releve_nr,richness_redlist,richness_all)%&gt;%\n  mutate(richness_redlist = replace_na(richness_redlist, 0))%&gt;%\n  mutate(richness_redlist_perc= richness_redlist/richness_all*100)%&gt;%\n  left_join(env%&gt;% select(releve_nr, forest))%&gt;%\n  summarise(redlist_mean_perc = mean(richness_redlist_perc), .by=forest)%&gt;%\n  arrange(forest)\n\nJoining with `by = join_by(species)`\nJoining with `by = join_by(releve_nr)`\nJoining with `by = join_by(releve_nr)`\nJoining with `by = join_by(releve_nr)`\n\n\n# A tibble: 4 Ã— 2\n  forest                redlist_mean_perc\n  &lt;chr&gt;                             &lt;dbl&gt;\n1 1_oak forest                       6.25\n2 2_oak hornbeam forest              6.24\n3 3_ravine forest                    5.03\n4 4_alluvial forest                  1.71\n\n\nBut I can also ask about diferences in abundances of some plant groups. What is the proportion of cover of alien species relative to total cover in different forests? I will again use the function we used for cover combination during import from Turboveg.\n\ncombine_cover &lt;- function(x){\n  while (length(x)&gt;1){\n    x[2] &lt;- x[1]+(100-x[1])*x[2]/100\n    x &lt;- x[-1]\n  }\n  return(x)\n}\n\n\nspe%&gt;% \n  left_join(spe %&gt;% \n              left_join(status)%&gt;% \n              filter(origin %in% c(\"arch\",\"neo\"))%&gt;%\n              summarize(cover_alien = combine_cover(cover_perc), \n                        .by=releve_nr))%&gt;%\n  left_join(spe %&gt;% \n              summarize(cover_total = combine_cover(cover_perc), \n                        .by=releve_nr))%&gt;%\n  distinct(releve_nr, cover_alien, cover_total)%&gt;%\n  mutate(cover_alien = replace_na(cover_alien, 0))%&gt;%\n  mutate(cover_alien_perc= cover_alien/cover_total*100)%&gt;%\n  left_join(env%&gt;% select(releve_nr, forest))%&gt;%\n  summarise(alien_cover_mean_perc = mean(cover_alien_perc), .by=forest)%&gt;%\n  arrange(forest)\n\nJoining with `by = join_by(species)`\nJoining with `by = join_by(releve_nr)`\nJoining with `by = join_by(releve_nr)`\nJoining with `by = join_by(releve_nr)`\n\n\n# A tibble: 4 Ã— 2\n  forest                alien_cover_mean_perc\n  &lt;chr&gt;                                 &lt;dbl&gt;\n1 1_oak forest                         0.0188\n2 2_oak hornbeam forest                1.24  \n3 3_ravine forest                      3.11  \n4 4_alluvial forest                    3.44",
    "crumbs": [
      "Data processing tutorial",
      "Basic data analyses"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/basic_analyses.html#community-weighted-means",
    "href": "DataProcessingTutorial/basic_analyses.html#community-weighted-means",
    "title": "Basic data analyses",
    "section": "2.4 Community weighted means",
    "text": "2.4 Community weighted means\nSummarise is often used for getting so-calledÂ community meansÂ or community weighted means. For example we have traits for individual species and we want to calculate a mean for each site and compare it. We can also consider to use abundance to weight the result. This is calledÂ community weighted meanÂ and it simply gives higher importance to those species that are more abundant and lower importance to the rare once. Here the abundance is approximated as percentage cover in the site. The example below compares mean plant height both weighted and unweighted. To have meaningful values, I looked just at the herb-layers species.\n\nspe %&gt;%\n  left_join(plant_height) %&gt;%\n  filter(layer==6)%&gt;%\n  summarise(meanHeight= mean(height_mean, na.rm=T),\n            meanHeight_weighted = weighted.mean(height_mean, cover_perc, na.rm = TRUE),\n            .by=releve_nr)\n\nJoining with `by = join_by(species)`\n\n\n# A tibble: 65 Ã— 3\n   releve_nr meanHeight meanHeight_weighted\n       &lt;dbl&gt;      &lt;dbl&gt;               &lt;dbl&gt;\n 1         1      0.364               0.322\n 2         2      0.459               0.504\n 3         3      0.408               0.388\n 4         4      0.570               0.515\n 5         5      0.566               0.528\n 6         6      0.577               0.573\n 7         7      0.498               0.559\n 8         8      0.423               0.710\n 9         9      0.543               0.494\n10        10      0.5                 0.527\n# â„¹ 55 more rows",
    "crumbs": [
      "Data processing tutorial",
      "Basic data analyses"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/basic_analyses.html#ellenberg-indicator-values",
    "href": "DataProcessingTutorial/basic_analyses.html#ellenberg-indicator-values",
    "title": "Basic data analyses",
    "section": "2.5 Ellenberg indicator values",
    "text": "2.5 Ellenberg indicator values\nIn the same way we can calculate community means across more variables. Here we will try theÂ Ellenberg indicator valuesÂ (abbreviated as EIV, measures of species demands for the particular factors, the higher value mean higher demands or affinity to habitats with higher values of these environmental factors). We will apply them just for presences of species, so no weights. Therefore we do not need to care that much for the differences among layers. However, we will keep each species only once (list of unique species for each plot), so we will remove information about layers first and use distinct. Alternative is to add #filter(Layer==6)%&gt;% if we want to focus on herb-layer only\n\nspe %&gt;%\n  left_join(indicator_values) %&gt;%\n  select(-c(layer,cover_perc))%&gt;%\n  distinct()%&gt;%\n  group_by(releve_nr)%&gt;%\n  summarise(across(starts_with(\"eiv\"), ~ mean(.x, na.rm = TRUE)))\n\nJoining with `by = join_by(species)`\n\n\n# A tibble: 65 Ã— 7\n   releve_nr eiv_light eiv_temperature eiv_moisture eiv_reaction eiv_nutrients\n       &lt;dbl&gt;     &lt;dbl&gt;           &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;\n 1         1      5.08            5.55         4.63         6.53          4.95\n 2         2      4.87            5.2          4.8          5             4.33\n 3         3      4.87            5.13         4.8          5             4.4 \n 4         4      5.32            5.53         4.47         5.79          4.26\n 5         5      6.07            5.57         4.14         5.57          3.86\n 6         6      5.69            5.56         4.44         6.56          5.25\n 7         7      5.74            5.47         4.42         6.26          4.95\n 8         8      5               5.38         4.67         5.43          4.62\n 9         9      5.26            5.74         4.53         6             4.58\n10        10      6.33            5.87         3.73         6.13          3.8 \n# â„¹ 55 more rows\n# â„¹ 1 more variable: eiv_salinity &lt;dbl&gt;\n\n\nBoxplots of Ellenberg-type indicator valuesÂ can be produced for example like this:\n\nspe %&gt;% \n  left_join(indicator_values) %&gt;%\n  select(-c(layer, cover_perc)) %&gt;%\n  distinct() %&gt;%\n  group_by(releve_nr) %&gt;%\n  summarise(across(starts_with(\"EIV\"), ~ mean(.x, na.rm = TRUE))) %&gt;%\n  left_join(env %&gt;% select(releve_nr, forest))%&gt;%\n  pivot_longer(\n    cols = starts_with(\"EIV\"),\n    names_to = \"EIV_variable\",\n    values_to = \"value\")%&gt;%\n  ggplot(aes(x = forest, y = value, fill = forest)) +\n  geom_boxplot() +\n  facet_wrap(~ EIV_variable, scales = \"free_y\") +\n  theme_bw()+\n  theme(legend.position = 'none')+\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))+\n  labs(x = NULL) +\n  labs (y = NULL)\n\nJoining with `by = join_by(species)`\nJoining with `by = join_by(releve_nr)`",
    "crumbs": [
      "Data processing tutorial",
      "Basic data analyses"
    ]
  },
  {
    "objectID": "Data/data_availability.html",
    "href": "Data/data_availability.html",
    "title": "Data",
    "section": "",
    "text": "Data from the Czech National Phytosociological Database (CNPD) are available directly from CNPD (for analyses at the national scale), from EVA (for analyses at the international scale within Europe) and from sPlot (for global analyses). Species occurrence data are available in the Pladias database. There are three regimes of data availability:\n\nPublic data freely available online.\nData available upon request from database managers for academic research or applications in nature conservation, but not for commercial purposes. Data requests should be sent by e-mail to Ilona KnollovÃ¡ (ğŸ“§ ikuzel@sci.muni.cz) or Milan ChytrÃ½ (ğŸ“§ chytry@sci.muni.cz) with a description of the intended use of the data and criteria of data selection (e.g.Â area, vegetation type and time interval) and the required format.\nNon-public data, which are stored in the central database but not made available to the public, or made available only for specific purposes specified by the data provider.\n\nData use in publications should be acknowledged using the standard database citation:\nChytrÃ½ M. & RafajovÃ¡ M. (2003): Czech National Phytosociological database: basic statistics of the available vegetation-plot data. Preslia 75: 1â€“15.\nThe papers where the data were published or authors of unpublished data should also be cited. These citations can be omitted if a data set from many different sources is used, in which no source is notably prevailing, and if the type of publication does not allow citing all the sources.",
    "crumbs": [
      "Data"
    ]
  },
  {
    "objectID": "About/history.html",
    "href": "About/history.html",
    "title": "History",
    "section": "",
    "text": "The development of the Czech Vegetation Database (formerly Czech National Phytosociological Database) was stimulated by the activities of the European Vegetation Survey Working Group of the International Association for Vegetation Science, which was founded in 1992. One of the aims of this group was to support national vegetation survey programs in European countries (Mucina et al.Â 1993). The creation of the national vegetation databases was a key activity towards this aim. To support database development, Stephan Hennekens developed the database management program Turboveg and provided it to various vegetation researchers and research groups in Europe (SchaminÃ©e & Hennekens 1995).\nJohn Rodwell from Lancaster University, UK, received funding for the project â€œSafeguarding the Biodiversity of Eastern Europeâ€ (1995â€“1998) from the Darwin Initiative of the British Government. The aim of this project was to train vegetation scientists from five central and eastern European countries, including the Czech Republic, in modern methods of vegetation survey, including the management of vegetation databases. The Czech participants included Milan ChytrÃ½ as a coordinator and Martin Duchoslav, Handrij HÃ¤rtel, TomÃ¡Å¡ KuÄera, KateÅ™ina Å umberovÃ¡ and LubomÃ­r TichÃ½ as team members. In close collaboration with Stephan Hennekens, Turboveg was prepared for use in the Czech Republic, which required compiling standard species lists and initial versions of the databases for bibliographic references and authors of plot records.\n\n\n\nVegetation database management training at Lancaster University, UK, 1996. From left to right: Stephan Hennekens, Milan ValachoviÄ, Milan ChytrÃ½, Handrij HÃ¤rtel, Martin Duchoslav, KateÅ™ina Å umberovÃ¡, LubomÃ­r TichÃ½.\n\n\nThanks to this training and further support from John Rodwell and Stephan Hennekens, as well as cooperation on the development of the common Austrian-Czech-Slovak species list with Harald Niklfeld, Walter Gutermann, Ladislav Mucina, Ivan JarolÃ­mek and Milan ValachoviÄ, the Czech National Phytosociological Database was founded by Milan ChytrÃ½ at Masaryk University in 1996 (ChytrÃ½ 1996, 1997). The training course on vegetation databanking using Turboveg for Czechia and Slovakia took place in Brno in February 1997, organized by Milan ChytrÃ½, John Rodwell, and his database assistant Julian Dring. This course, attended by 42 participants from Czechia nad 8 from Slovakia, helped develop an organizational structure for the national vegetation database, with a central database at Masaryk University in Brno, managed by Milan ChytrÃ½, and a network of local collaborators in other important botanical institutions across the country, most notably the Institute of Botany of the Czech Academy of Sciences, Charles University in Prague, PalackÃ½ University in Olomouc, University of South Bohemia in ÄŒeskÃ© BudÄ›jovice, and the Czech University of Life Sciences in Prague.\n\n\n\nJohn Rodwell (left) and his assistant Julian Dring (right), organizing a vegetation database management course for Czechia and Slovakia in Brno, February 1997.\n\n\nhanks to the collective effort of several collaborators, the database grew rapidly by harmonizing the already existing data in various electronic formats and digitizing data from the literature and field notebooks. In October 1997, the database contained 6408 vegetation plots (ChytrÃ½ 1997). From 1999, Marie RafajovÃ¡ was appointed as a full-time data manager on a Czech Science Foundation project obtained by M. ChytrÃ½. This enabled the massive digitization of data, resulting in 55,310 vegetation plots being digitized by November 2002 (ChytrÃ½ & RafajovÃ¡ 2003). Marie RafajovÃ¡ left the team in 2003, being successively replaced by Ilona KnollovÃ¡ (KuÅ¾elovÃ¡), Zdenka PreislerovÃ¡ (OtÃ½pkovÃ¡), Å tÄ›pÃ¡nka KrÃ¡lovÃ¡, Dana HolubovÃ¡ (MichalcovÃ¡) and again Ilona KnollovÃ¡. Further plots were obtained through a series of Czech Science Foundation projects that supported the preparation of the monograph Vegetation of the Czech Republic (ChytrÃ½ 2007â€“2013). These plots were provided by project collaborators or digitized from older literature, nature conservation reports and field notebooks. By May 2012, the database contained 99,586 vegetation plots (ChytrÃ½ & MichalcovÃ¡ 2012).\n\n\n\nParticipants of a vegetation database training course in Brno, February 1997.\n\n\nIn 2011, the Czech National Phytosociological Database was indexed in the Global Index of Vegetation-Plot Databases (GIVD, Dengler et al.Â 2011) with the code EU-CZ-001. In 2012, it became one of the founding members of the European Vegetation Archive, an integrated database of European vegetation plots (ChytrÃ½ et al.Â 2016). In 2013, it joined sPlot, the Global Vegetation Database (Bruelheide et al.Â 2019). Through these partnerships, Czech vegetation data contributed to numerous synthetic studies of vegetation on the European and global scales. Repeated records from the same vegetation plots included in the database have also been incorporated into the international database ReSurveyEurope (KnollovÃ¡ et al.Â 2024). Moreover, the species occurrence records from the database were imported into the Pladias â€“ Database of the Czech Flora and Vegetation, which was launched in an online version in 2018 and integrated plant species distribution records from multiple sources (Wild et al.Â 2019, ChytrÃ½ et al.Â 2021).\nReferences\n\nBruelheide H., Dengler J., JimÃ©nezâ€Alfaro B., Purschke O., Hennekens S. M., ChytrÃ½ M., Pillar V. D., Jansen F., Kattge J., Sandel B., Aubin I., Biurrun I., Field R., Haider S., Jandt U., Lenoir J., Peet R. K., Peyre G., Sabatini F. M., Schmidt M., Schrodt F., Winter M., AÄ‡iÄ‡ S., Agrillo E., Alvarez M., AmbarlÄ± D., Angelini P., Apostolova I., Arfin Khan M. A., Arnst E., Attorre F., Baraloto C., Beckmann M., Berg C., Bergeron Y., Bergmeier E., Bjorkman A. D., Bondareva V., Borchardt P., Bottaâ€DukÃ¡t Z., Boyle B., Breen A., Brisse H., Byun C., Cabido M. R., Casella L., Cayuela L., ÄŒernÃ½ T., Chepinoga V., Csiky J., Curran M., Ä†uÅ¡terevska R., DajiÄ‡ StevanoviÄ‡ Z., De Bie E., De Ruffray P., De Sanctis M., Dimopoulos P., Dressler S., EjrnÃ¦s R., Elâ€Sheikh M. A. E. M., Enquist B., Ewald J., FagÃºndez J., Finckh M., Font X., Forey E., Fotiadis G., GarcÃ­aâ€Mijangos I., de Gasper A. L., Golub V., Gutierrez A. G., Hatim M. Z., He T., Higuchi P., HolubovÃ¡ D., HÃ¶lzel N., Homeier J., Indreica A., IsÄ±k GÃ¼rsoy D., Jansen S., Janssen J., Jedrzejek B., JirouÅ¡ek M., JÃ¼rgens N., KÄ…cki Z., KavgacÄ± A., Kearsley E., Kessler M., KnollovÃ¡ I., Kolomiychuk V., Korolyuk A., Kozhevnikova M., Kozub Å., KrstonoÅ¡iÄ‡ D., KÃ¼hl H., KÃ¼hn I., Kuzemko A., KÃ¼zmiÄ F., Landucci F., Lee M. T., Levesley A., Li C.-F., Liu H., Lopezâ€Gonzalez G., Lysenko T., MacanoviÄ‡ A., Mahdavi P., Manning P., MarcenÃ² C., Martynenko V., Mencuccini M., Minden V., Moeslund J. E., Moretti M., MÃ¼ller J. V., Munzinger J., Niinemets Ãœ., Nobis M., Noroozi J., Nowak A., Onyshchenko V., Overbeck G. E., Ozinga W. A., Pauchard A., Pedashenko H., PeÃ±uelas J., PÃ©rezâ€Haase A., Peterka T., PetÅ™Ã­k P., Phillips O. L., Prokhorov V., RaÅ¡omaviÄius V., Revermann R., Rodwell J., Ruprecht E., RÅ«siÅ†a S., Samimi C., SchaminÃ©e J. H. J., Schmiedel U., Å ibÃ­k J., Å ilc U., Å kvorc Å½., Smyth A., Sop T., Sopotlieva D., Sparrow B., StanÄiÄ‡ Z., Svenning J.-C., Swacha G., Tang Z., Tsiripidis I., Turtureanu P. D., Ugurlu E., Uogintas D., ValachoviÄ M., Vanselow K. A., Vashenyak Y., Vassilev K., VÃ©lezâ€Martin E., Venanzoni R., Vibrans A. C., Violle C., Virtanen R., von Wehrden H., Wagner V., Walker D. A., Wana D., Weiher E., Wesche K., Whitfeld T., Willner W., Wiser S., Wohlgemuth T., Yamalov S., Zizka G. & Zverev A. (2019) sPlot â€“ a new tool for global vegetation analyses.Â Journal of Vegetation ScienceÂ 30: 161â€“186.Â https://doi.org/10.1111/jvs.12710\nChytrÃ½ M. (1996) DatabÃ¡zovÃ½ systÃ©m pro projekt pÅ™ehledu vegetace ÄŒeskÃ© republiky (Database system for the project of the vegetation survey of the Czech Republic). ZprÃ¡vy ÄŒeskÃ© botanickÃ© spoleÄnosti 31: 193â€“200. [PDF]\nChytrÃ½ M. (1997) ÄŒeskÃ¡ nÃ¡rodnÃ­ fytocenologickÃ¡ databÃ¡ze: poÄÃ¡teÄnÃ­ stav a perspektivy (Czech National Phytosociological Database: initial state and perspectives). ZprÃ¡vy ÄŒeskÃ© botanickÃ© spoleÄnosti, MateriÃ¡ly 15: 27â€“40. [PDF]\nChytrÃ½ M. (ed.) (2007â€“2013) Vegetace ÄŒeskÃ© republiky 1â€“4 / Vegetation of the Czech Republic 1â€“4. Academia, Praha. [PDF]\nChytrÃ½ M., Danihelka J., Kaplan Z., Wild J., HolubovÃ¡ D., NovotnÃ½ P., Å˜eznÃ­ÄkovÃ¡ M., Rohn M., DÅ™evojan P., Grulich V., KlimeÅ¡ovÃ¡ J., LepÅ¡ J., LososovÃ¡ Z., Pergl J., SÃ¡dlo J., Å marda P., Å tÄ›pÃ¡nkovÃ¡ P., TichÃ½ L., AxmanovÃ¡ I., BartuÅ¡kovÃ¡ A., BlaÅ¾ek P., Chrtek J. Jr., Fischer F. M., Guo W.-Y., Herben T., JanovskÃ½ Z., KoneÄnÃ¡ M., KÃ¼hn I., MoravcovÃ¡ L., PetÅ™Ã­k P., Pierce S., Prach K., ProkeÅ¡ovÃ¡ H., Å tech M., TÄ›Å¡itel J., TÄ›Å¡itelovÃ¡ T., VeÄeÅ™a M., ZelenÃ½ D. & PyÅ¡ek P. (2021) Pladias Database of the Czech Flora and Vegetation.Â PresliaÂ 93: 1â€“87.Â https://doi.org/10.23855/preslia.2021.001\nChytrÃ½ M., Hennekens S.M., JimÃ©nez-Alfaro B., KnollovÃ¡ I., Dengler J., Jansen F., Landucci F., SchaminÃ©e J.H.J., AÄ‡iÄ‡ S., Agrillo E., AmbarlÄ± D., Angelini P., Apostolova I., Attorre F., Berg C., Bergmeier E., Biurrun I., Botta-DukÃ¡t Z., Brisse H., Campos J.A., CarlÃ³n L., ÄŒarni A., Casella L., Csiky J., Ä†uÅ¡terevska R., DajiÄ‡ StevanoviÄ‡ Z., Danihelka J., De Bie E., de Ruffray P., De Sanctis M., DickorÃ© W.B., Dimopoulos P., Dubyna D., Dziuba T., EjrnÃ¦s R., Ermakov N., Ewald J., Fanelli G., FernÃ¡ndez-GonzÃ¡lez F., FitzPatrick Ãš., Font X., GarcÃ­a-Mijangos I., GavilÃ¡n R.G., Golub V., Guarino R., Haveman R., Indreica A., IÅŸÄ±k GÃ¼rsoy D., Jandt U., Janssen J.A.M., JirouÅ¡ek M., KÄ…cki Z., KavgacÄ± A., Kleikamp M., Kolomiychuk V., KrstivojeviÄ‡ Ä†uk M., KrstonoÅ¡iÄ‡ D., Kuzemko A., Lenoir J., Lysenko T., MarcenÃ² C., Martynenko V., MichalcovÃ¡ D., Moeslund J.E., Onyshchenko V., Pedashenko H., PÃ©rez-Haase A., Peterka T., Prokhorov V., RaÅ¡omaviÄius V., RodrÃ­guez-Rojo M.P., Rodwell J.S., Rogova T., Ruprecht E., RÅ«siÅ†a S., Seidler G., Å ibÃ­k J., Å ilc U., Å kvorc Å½., Sopotlieva D., StanÄiÄ‡ Z., Svenning J.-C., Swacha G., Tsiripidis I., Turtureanu P.D., UÄŸurlu E., Uogintas D., ValachoviÄ M., Vashenyak Y., Vassilev K., Venanzoni R., Virtanen R., Weekes L., Willner W., Wohlgemuth T. & Yamalov S. (2016) European Vegetation Archive (EVA): an integrated database of European vegetation plots.Â Applied Vegetation ScienceÂ 19: 173â€“180.Â https://doi.org/10.1111/avsc.12191\nChytrÃ½ M. & MichalcovÃ¡ D. (2012) Czech National Phytosociological Database.Â Biodiversity and EcologyÂ 4: 345. [PDF]\nChytrÃ½ M. & RafajovÃ¡ M. (2003): Czech National Phytosociological Database: basic statistics of the available vegetation-plot data. Preslia 75: 1â€“15. [PDF]\nDengler J., Jansen F., GlÃ¶ckler F., Peet R.K., De CÃ¡ceres M., ChytrÃ½ M., Ewald J., Oldeland J., Lopez-Gonzalez G., Finckh M., Mucina L., Rodwell J.S., SchaminÃ©e J.H.J. & Spencer N. (2011) The Global Index of Vegetation-Plot Databases (GIVD): a new resource for vegetation science.Â Journal of Vegetation ScienceÂ 22: 582â€“597.Â https://doi.org/10.1111/j.1654-1103.2011.01265.x\nKnollovÃ¡ I., ChytrÃ½ M., Bruelheide H., Dullinger S., Jandt U., Bernhardt-RÃ¶mermann M., Biurrun I., de Bello F., Glaser M., Hennekens S., Jansen F., JimÃ©nez-Alfaro B., KadaÅ¡ D., Kaplan E., KlinkovskÃ¡ K., Lenzner B., Pauli H., Sperandii M.G., Verheyen K., Winkler M., Abdaladze O., AÄ‡iÄ‡ S., Acosta A.T.R., Alignier A., Andrews C., Arlettaz R., Attorre F., AxmanovÃ¡ I., Babbi M., Baeten L., Baran J., Barni E., Benito-Alonso J.-L., Berg C., Bergamini A., Berki I., Boch S., Bock B., Bode F., Bonari G., BoublÃ­k K., Britton A.J., Brunet J., Bruzzaniti V., Buholzer S., Burrascano S., Campos J.A., Carlsson B.-G., Carranza M.L., ÄŒernÃ½ T., Charmillot K., Chiarucci A., Choler P., ChytrÃ½ K., Corcket E., Csecserits A., Cutini M., Czarniecka-Wiera M., Danihelka J., de Francesco M.C., De Frenne P., Di Musciano M., De Sanctis M., DeÃ¡k B., Decocq G., Dembicz I., Dengler J., Di Cecco V., Dick J., Diekmann M., Dierschke H., DirnbÃ¶ck T., Doerfler I., DoleÅ¾al J., DÃ¶ring U., Durak T., Dwyer C., EjrnÃ¦s R., Ermakova I., Erschbamer B., Fanelli G., FernÃ¡ndez-Calzado M-R., Fickert T., Fischer A., Fischer M., Foremnik K., Frouz J., GarcÃ­a-GonzÃ¡lez R., GarcÃ­a-Magro D., GarcÃ­a-Mijangos I., GavilÃ¡n R.G., Germ M., Ghosn D., Gigauri K., Gizela J., Golob A., Golub V., GÃ³mez-GarcÃ­a D., Gowing D., Grytnes J.-A., GÃ¼ler B., GutiÃ©rrez-GirÃ³n A., Haase P., Haider S., HÃ¡jek M., Halassy M., HarÃ¡sek M., HÃ¤rdtle W., Heinken T., Hester A., Humbert J.-Y., IbÃ¡Ã±ez R., Illa E., Jaroszewicz B., Jensen K., Jentsch A., JirouÅ¡ek M., KalnÃ­kovÃ¡ V., Kanka R., Kapfer J., Kazakis G., Kermavnar J., Kesting S., Khanina L., Kindermann E., KotrÃ­k M., KouteckÃ½ T., Kozub Å., Kuhn G., Kutnar L., La Montagna D., Lamprecht A., Lenoir J., LepÅ¡ J., Leuschner C., Lorite J., Madsen B., Ugarte R.M., Malicki M., Maliniemi T., MÃ¡liÅ¡ F., Maringer A., Marrs R., Matesanz S., Metze K., Meyer S., Millett J., Mitchell R.J., Moeslund J.E., Moiseev P., di Cella U.M., MudrÃ¡k O., MÃ¼ller F., MÃ¼ller N., Naaf T., Nagy L., Napoleone F., Nascimbene J., NavrÃ¡tilovÃ¡ J., Ninot J.M., Niu Y., Normand S., Ogaya R., Onipchenko V., Orczewska A., Ortmann-Ajkai A., Pakeman R.J., Pardo I., PÃ¤tsch R., Peet R.K., Penuelas J., Peppler-Lisbach C., PÃ©rez-HernÃ¡ndez J., PÃ©rez-Haase A., Petraglia A., PetÅ™Ã­k P., Pielech R., PiÃ³rkowski H., Pladevall-Izard E., Poschlod P., Prach K., Praleskouskaya S., Prokhorov V., Provoost S., PuÈ™caÈ™ M., PustkovÃ¡ Å ., Randin C.F., RaÅ¡omaviÄius V., ReczyÅ„ska K., RÃ©dei T., Å˜ehounkovÃ¡ K., Richner N., Risch A.C., Rixen C., Rosbakh S., Roscher C., Rosenthal G., Rossi G., RÃ¶tzer H., Roux C., Rumpf S.B., Ruprecht E., RÅ«siÅ†a S., Sanz-Zubizarreta I., Schindler M., Schmidt W., Schories D., Schrautzer J., Schubert H., Schuetz M., Schwabe A., Schwaiger H., Schwartze P., Å ebesta J., Seiler H., Å ilc U., Silva V., Å milauer P., Å milauerovÃ¡ M., Sperle T., Stachurska-SwakoÅ„ A., Stanik N., Stanisci A., Steffen K., Storm C., Stroh H.G., Sugorkina N., Åšwierkosz K., Åšwierszcz S., Szymura M., Teleki B., ThÃ©baud G., Theurillat J.-P., TichÃ½ L., Treier U.A., Turtureanu P.D., UjhÃ¡zy K., UjhÃ¡zyovÃ¡ M., Ursu TM., UziÄ™bÅ‚o A.K., ValkÃ³ O., Van Calster H., Van Meerbeek K., Vandevoorde B., Vandvik V., Varricchione M., Vassilev K., Villar L., Virtanen R., Vittoz P., Voigt W., von Hessberg A., von Oheimb G., Wagner E., Walther G.-R., Wellstein C., Wesche K., Wilhelm M., Willner W., Wipf S., Wittig B., Wohlgemuth T., Woodcock B.A., Wulf M. & Essl F. (2024) ReSurveyEurope: A database of resurveyed vegetation plots in Europe.Â Journal of Vegetation ScienceÂ 35: e13235.Â https://doi.org/10.1111/jvs.13235\nMucina L., Rodwell J.S., SchaminÃ©e J.H.J. & Dierschke H. (1993) European Vegetation Survey: Current state of some national programmes. Journal of Vegetation Science 4: 429â€“438. https://doi.org/10.2307/3235603\nWild J., Kaplan Z., Danihelka J., PetÅ™Ã­k P., ChytrÃ½ M., NovotnÃ½ P., Rohn M., Å ulc V., BrÅ¯na J., Chobot K., Ekrt L., HolubovÃ¡ D., KnollovÃ¡ I., KociÃ¡n P., Å tech M., Å tÄ›pÃ¡nek J. & Zouhar V. (2019) Plant distribution data for the Czech Republic integrated in the Pladias database.Â PresliaÂ 91: 1â€“24.Â https://doi.org/10.23855/preslia.2019.001",
    "crumbs": [
      "About",
      "History"
    ]
  },
  {
    "objectID": "About/acknowledgements.html",
    "href": "About/acknowledgements.html",
    "title": "Acknowledgements",
    "section": "",
    "text": "Since its foundation in 1996, more than 200 people have contributed to the development of the Czech Vegetation Database by providing original vegetation-plot data, digitizing data from the literature, standardizing, cleaning and correcting the data, georeferencing vegetation plots, preparing and updating the taxonomic backbone, offering conceptual advice, and providing IT support. Many thanks to all of them:\n\n\n\n\nIrena AxmanovÃ¡ (VeselÃ¡)\nMarcel BartoÅ¡\nDavid BeleÅ¡\nLucie BenediktovÃ¡\nEliÅ¡ka BlaÅ¾ejovÃ¡ (HorodyskÃ¡)\nDenisa BlaÅ¾kovÃ¡ â€ \nKarel BoublÃ­k\nPavel Brych\nKateÅ™ina BubÃ­kovÃ¡\nLucia CachovanovÃ¡\nJindÅ™ich Chlapek\nMarkÃ©ta ChudomelovÃ¡\nHelena ChytrÃ¡ (ProkeÅ¡ovÃ¡)\nKryÅ¡tof ChytrÃ½\nMilan ChytrÃ½\nJaroslava CieslarovÃ¡\nDavid CigÃ¡nek\nÅ Ã¡rka CimalovÃ¡\nOndÅ™ej CudlÃ­n\nJaroslav ÄŒÃ¡p\nAlÅ¾bÄ›ta ÄŒejkovÃ¡\nBarbora ÄŒepelovÃ¡\nMartin ÄŒernÃ½\nTomÃ¡Å¡ ÄŒernÃ½\nMartin DanÄÃ¡k\nPavel DanÄ›k\nJiÅ™Ã­ Danihelka\nDaniel DÃ­tÄ›\nJan DivÃ­Å¡ek\nCtibor DolejÅ¡Ã­\nJan DoleÅ¾al\nJana ÄoubalovÃ¡\nJan Douda\nJulian Dring\nPavel DÅ™evojan\nLydie DudovÃ¡ (NavrÃ¡tilovÃ¡)\nMartin Duchoslav\nHelena DuÅ¡kovÃ¡\nJana DvoÅ™Ã¡kovÃ¡\nLibor Ekrt\nViktoria Eltsova\nMartina FabÅ¡iÄovÃ¡\nKarel Fajmon\nZuzana FajmonovÃ¡ (RozbrojovÃ¡)\nPetr Filippov\nJarmila FilippovovÃ¡\nKlÃ¡ra FriesovÃ¡ (KlinkovskÃ¡)\nZuzana FronkovÃ¡\nJiÅ™Ã­ Galda\nMichal GerÅ¾a\nMarek Gonda\nTomÃ¡Å¡ Grulich\nVÃ­t Grulich â€ \nWalter Gutermann â€ \nMichal HÃ¡jek\nPetra HÃ¡jkovÃ¡\nJana HalÃºzovÃ¡ (StrakovÃ¡)\nPetra HanÃ¡kovÃ¡\nMartin HarÃ¡sek\nHandrij HÃ¤rtel\nKryÅ¡tof Havelka\nHelena HavrÃ¡nkovÃ¡ (AdÃ¡mkovÃ¡)\nRadim HÃ©dl\nMonika HejdovÃ¡\nStephan M. Hennekens\nAleÅ¡ Hoffmann\nDana HolubovÃ¡ (MichalcovÃ¡)\nViera HorÃ¡kovÃ¡ (DemianovÃ¡)\nLucie HradilovÃ¡\nRichard HrivnÃ¡k\nZdenka HroudovÃ¡\n\n\n\n\nJaroslav Hruban\nMonika HrubanovÃ¡ (DrÅ¡kovÃ¡)\nPetr Hubatka\nIvan JarolÃ­mek\nIvan Jindra\nMartin JirouÅ¡ek\nJana JirouÅ¡kovÃ¡ (BoÅ¾kovÃ¡)\nBlanka JÃ­rÅ¯\nTereza JuÅ™enovÃ¡ (KoubkovÃ¡)\nJan JuÅ™ica\nMichal JuÅ™Ã­Äek\nJiÅ™Ã­ JuÅ™iÄka\nKamila JuÅ™iÄkovÃ¡\nDaniel KadaÅ¡\nVeronika KalnÃ­kovÃ¡\nVeronika KalusovÃ¡\nAdam Kantor\nZdenÄ›k Kaplan\nKatrin KarimovÃ¡\nPetr KarlÃ­k\nAlexandra KlaudisovÃ¡\nLeoÅ¡ KlimeÅ¡ â€ \nIlona KnollovÃ¡ (KuÅ¾elovÃ¡)\nJiÅ™Ã­ KociÃ¡n\nMartin KoÄÃ­\nBranislav KopÄan\nJan KoÅ¡nar\nAlica KoÅ¡uthovÃ¡ (DingovÃ¡)\nFrantiÅ¡ek Krahulec\nÅ tÄ›pÃ¡nka KrÃ¡lovÃ¡\nLucie KratochvÃ­lovÃ¡\nZdenÄ›k KropÃ¡Ä â€ \nPavel KÅ™Ã­Å¾ek\nTomÃ¡Å¡ KuÄera\nAnna KuÄerovÃ¡\nAnna KuÄerovÃ¡ (KulÃ­kovÃ¡)\nPetr KuneÅ¡\nJosef KutlvaÅ¡r\nJitka LaburdovÃ¡\nFlavia Landucci\nDeana LÃ¡nÃ­kovÃ¡ (SimonovÃ¡)\nMartin LepÅ¡Ã­\nJarmila LorencovÃ¡ (UrbÃ¡nkovÃ¡)\nZdeÅˆka LososovÃ¡\nHana LukÅ¡Ã­kovÃ¡\nPavel Lustyk\nSamuel LvonÄÃ­k\nMartina MackÅ¯ (NejezchlebovÃ¡)\nÅ tÄ›pÃ¡nka MarkovÃ¡ (ÄŒÃ­Å¾kovÃ¡)\nIvona MatÄ›jkovÃ¡\nMichal MazÃ¡k\nJÃ¡n Medal\nKristina MerunkovÃ¡\nJan MlÃ¡dek â€ \nZuzana MyÅ¡kovÃ¡\nTereza NÃ¡hlÃ­kovÃ¡\nJana NavrÃ¡tilovÃ¡ (ErnestovÃ¡)\nJiÅ™Ã­ NÄ›mec\nZdenka NeuhÃ¤uslovÃ¡ â€ \nHarald Niklfeld â€ \nJana NovÃ¡\nJan NovÃ¡k\nPavel NovÃ¡k\nKateÅ™ina NovÃ¡kovÃ¡ (PÃ­Å¡Å¥kovÃ¡)\nIvan OstrÃ½\nJiÅ™Ã­ OuÅ™ada\nMarcela PaloudovÃ¡\nPetra PavlÃ­ÄkovÃ¡\nSylvie PechÃ¡ÄkovÃ¡\nJan Pergl\nTomÃ¡Å¡ Peterka\n\n\n\n\nMichaela PetrovÃ¡\nPetr PetÅ™Ã­k\nLenka PivoÅˆkovÃ¡\nZuzana PleskovÃ¡\nMarie PopelÃ¡Å™ovÃ¡ (DerkovÃ¡)\nOndÅ™ej Popelka\nJana PosslovÃ¡ (KÅ¯rovÃ¡)\nJan PranÄl\nRomana PrausovÃ¡\nZdenka PreislerovÃ¡ (OtÃ½pkovÃ¡)\nLenka ProkopovÃ¡\nPetr PyÅ¡ek\nMarie RafajovÃ¡\nFrank Richter\nLudmila RivolovÃ¡\nJohn S. Rodwell\nJaroslav Rohel\nJan RoleÄek\nRomana RouÄkovÃ¡\nJiÅ™Ã­ Rozehnal\nEva RozehnalovÃ¡\nVlastik Rybka\nMarcela Å˜eznÃ­ÄkovÃ¡ (HavlovÃ¡)\nJiÅ™Ã­ SÃ¡dlo\nVojtÄ›ch SedlÃ¡Äek\nHana SekerkovÃ¡\nVojtÄ›ch Sobotka\nMartina SojnekovÃ¡\nZdenÄ›k SoldÃ¡n\nZbynÄ›k SovÃ­k\nLenka SovÃ­kovÃ¡\nVeronika SrnkovÃ¡\nLenka StaÅˆkovÃ¡ (SalabovÃ¡)\nEliÅ¡ka SuntychovÃ¡\nTomÃ¡Å¡ SvaÄina\nEva Å aldovÃ¡\nMilan Å enkÃ½Å™ â€ \nAnna Å Ã­movÃ¡\nPetr Å marda\nEva Å merdovÃ¡ (HettenbergerovÃ¡)\nMarkÃ©ta Å pelinovÃ¡ (PrÅ¯chovÃ¡)\nPetra Å tÄ›pÃ¡nkovÃ¡\nJitka Å tÄ›rbovÃ¡ (EffmertovÃ¡)\nKateÅ™ina Å umberovÃ¡\nMarkÃ©ta TÃ¡borskÃ¡\nPÅ™emysl TÃ¡jek\nVojtÄ›ch TaraÅ¡ka\nLubomÃ­r TichÃ½\nJana TkÃ¡ÄikovÃ¡ (NovosadovÃ¡)\nAdam TrÄka\nMilan ValachoviÄ\nMartin VeÄeÅ™a\nKateÅ™ina VejvodovÃ¡\nAdam Veleba\nJiÅ™Ã­ Velebil\nJiÅ™Ã­ Vicherek â€ \nOndÅ™ej Vild\nKarla VincenecovÃ¡\nRichard ViÅ¡ÅˆÃ¡k\nMichaela VÃ­tkovÃ¡\nPavla VlÄkovÃ¡\nMartin VojÃ­k\nJaroslav Vojta\nAlena VydrovÃ¡\nTomÃ¡Å¡ VymyslickÃ½\nPetr VyslouÅ¾il\nTomÃ¡Å¡ ZedÃ­nek\nDavid ZelenÃ½\nIva ZÃ­tkovÃ¡\nDominik Zukal\nKristÃ½na Å½Ã¡kovÃ¡",
    "crumbs": [
      "About",
      "Acknowledgements"
    ]
  },
  {
    "objectID": "About/turboveg_windows.html",
    "href": "About/turboveg_windows.html",
    "title": "Turboveg for Windows",
    "section": "",
    "text": "The Czech Vegetation Database is stored and managed in the Turboveg 2 program, which was developed specifically for managing vegetation-plot databases by Stephan Hennekens (Hennekens & SchaminÃ©e 2001). This program and the database format it supports have become widespread across Europe and beyond. We encourage all data contributors to the Czech Vegetation Database to use this program to digitize their vegetation-plot data.\n\n1. Installation\nTo obtain the version of Turboveg optimized for Czech data, please contact Ilona KnollovÃ¡ (ikuzel@sci.muni.cz) or Milan ChytrÃ½ (chytry@sci.muni.cz). This version is not available for international users who work with data from other countries. If these users are interested in working with Turboveg, they should contact database coordinators in their countries or Stephan Hennnekens.\n\n\n2. Updates\nProgram update\nAfter the Turboveg installation, the program should be updated to the current version from the Turboveg website (select â€International, single user versionâ€œ).\nInstallation and update of the Czech species list\nThe standard Turboveg list of the Czech flora (common with the standard list of Slovak flora) should be downloaded here:\n\nspecies.zip (version 28 November 2024)\n\nExtract this file. After extraction, you will receive a folder named Czechia_Slovakia_2015, which should be copied to the folder /TURBOWIN/species on your computer. In the Turboveg program, assign the species list to each specific database using Database/Modify attributes.\nInstallation and update of the common database directories\nThe standard directories for specific header-data variables should be downloaded from here:\n\npopup.zip (version 16 December 2024)\n\nExtract this file to the folder /TURBOWIN/popup (old files should be rewritten). If there are problems with the syntaxon list, follow the instructions here.\n\n\n3. Instructions\nBefore storing the vegetation-plot data entered into Turboveg in the Czech Vegetation Database, each plot must have a unique number. To guarantee that your plots have unique numbers, contact Ilona KnollovÃ¡ (ikuzel@sci.muni.cz), who may assign a range of plot numbers to you. The list of numbers assigned to individual collaborators is here. Collaborators who have not been assigned to a range of plot numbers should code their plots starting from no. 1. Their plots will be renumbered by the coordinator once they are sent to the central database. If collaborators with assigned plot numbers enter plots from published sources, the bibliographic references should have numbers from the same numerical range.\nTurboveg manual for beginners (in Czech) is here. You can download an empty database template with standard header data fields used in the Czech Vegetation Database. Restore this template to the folder /TURBOWIN/data and rename it.\n\n\n4. Taxonomic and nomenclatural standards\nTo ensure compatibility among different datasets, the Czech Vegetation Database uses standardized species lists included in the Czech version of Turboveg.\nThe list of vascular plant species (including some other infraspecific and infrageneric taxa) was prepared by the late Professor Harald Niklfeld and Dr.Â Walter Gutermann (University of Vienna) in 1996 based on an updated version of Liste der GefÃ¤ÃŸpflanzen Mitteleuropas (Ehrendorfer 1973). This species list contains plant species occurring in Czechia, Slovakia, and Austria. In 2015, JiÅ™Ã­ Danihelka updated this species list to reflect additions to the Czech flora published in Danihelka et al.Â (2012), while keeping compatibility with the previous list. This species list is currently used by both the Czech Vegetation Database and the Central Database of Phytosociological RelevÃ©s in Slovakia.\nThe lists of bryophytes and lichens follow Frahm et al.Â (1995) and PiÅ¡Ãºt et al.Â (1993), respectively.\nReferences\n\nDanihelka J., Chrtek J. Jr.Â & Kaplan Z. (2012) Checklist of vascular plants of the Czech Republic. Preslia 84: 647â€“811.\nEhrendorfer F. (ed.) (1973) Liste der GefÃ¤ÃŸpflanzen Mitteleuropas. Ed. 2. G. Fischer, Stuttgart.\nFrey W., Frahm J. P., Fischer E. & Lobin W. (1995) Die Moos- und Farnpflanzen Europas. G. Fischer, Stuttgart.\nPiÅ¡Ãºt I., LackovicovÃ¡ A. & LisickÃ¡ E. (1993) SÃºpis liÅ¡ajnÃ­kov Slovenska. BiolÃ³gia, 48, Suppl. 1: 53â€“98.",
    "crumbs": [
      "About",
      "Turboveg for Windows"
    ]
  },
  {
    "objectID": "Data/data_description.html",
    "href": "Data/data_description.html",
    "title": "Data description",
    "section": "",
    "text": "Data description\nFollowing the structure of the Turboveg database management software, vegetation-plot data in the Czech Vegetation Database are divided into three parts:\n\nSpecies data\nHeader data\nRemarks\n\n\n1. Species data\nSpecies data contain unique plot identifiers (RELEVE_NR), species numbers (SPECIES_NR), cover-abundance grade for each species record (COVER_CODE), and vegetation layer for each species record (LAYER). Species numbers are linked to species names, and cover-abundances are linked to percentage covers using translation tables.\n\n\n2. Header data\nHeader data contain information related to vegetation plots other than information on species and their cover-abundances. They include details of sampling methods, location, vegetation structure, vegetation type, and environmental information.\nIn addition to basic variables, the database also contains variables with outdated content (replaced by new variables with up-to-date content), variables that are rarely or never used, and one variable with non-unified content. Individual private databases that have been incorporated into the Czech Vegetation Database may also have contained other variables that are specific to those databases.\n\n2.1. Basic header-data variables\nRelevÃ© number (RELEVE_NR). Unique numerical code of the vegetation plot in the database.\nCountry code (COUNTRY). Two-letter country code according to ISO 3166-1 alpha-2. All plots recorded within the territory of the Czech Republic have the value â€œCZâ€.\nBiblioreference (REFERENCE). Bibliographic reference for vegetation plots that have been published in a citable source (article, book, student thesis, research report). A database of biblioreferences is available here: https://www.sci.muni.cz/botany/tvref/.\nNumber of table in publication (TABLE_NR). Number of the table in which the vegetation plot was published in the cited source. If the plot was separately rather than included in a table, the page number is given after the abbreviation â€œp.â€ (e.g., â€œp.Â 15â€).\nNumber of relevÃ© in table (NR_IN_TAB). Number of the vegetation plot in the cited source.\nCover-abundance scale (COVER SCALE). Species cover was recorded in vegetation plots either as percentages or using various scales derived from percentage cover intervals. Some scales are supplemented, for species with low cover, by grades expressing the number of individuals. The database contains both general scales used by multiple researchers and scales defined for a single purpose. In the database, grades of all scales are converted to the midpoint of the percentage interval they represent. General scales and their conversions to percentages are as follows (unused codes refer to scales defined only for a single purpose):\n\n00 â€“ Percentage (%)\n01 â€“ Braun-Blanquet (old), with seven grades: r = 1%, + = 2%, 1 = 3%, 2 = 13%, 3 = 38%, 4 = 63%, 5 = 88%\n02 â€“ Braun-Blanquet (new), with nine grades: r = 1%, + = 2%, 1 = 3%, 2m = 4%, 2a = 8%, 2b = 18%, 3 = 38%, 4 = 63%, 5 = 88%\n03 â€“ Londo: r1 = 1%, p1 = 1%, a1 = 1%, m1 = 1%, r2 = 2%, p2 = 2%, a2 = 2%, m2 = 2%, r4 = 4%, p4 = 4%, a4 = 4%, m4 = 4%, 1- = 7%, 1 = 10%, 1+ = 12%, 2- = 17%, 2 = 20%, 2+ = 22%, 3- = 27%, 3 = 30%, 3+ = 32%, 4- = 37%, 4 = 40%, 4+ = 42%, 5- = 47%, 5 = 50%, 5+ = 52%, 6- = 57%, 6 = 60%, 6+ = 62%, 7- = 67%, 7 = 70%, 7+ = 72%, 8- = 77%, 8 = 80%, 8+ = 82%, 9- = 87%, 9 = 90%, 9+ = 92%, 10 = 97%\n04 â€“ Presence/Absence: x, 1\n05 â€“ Ordinal scale (1â€“9), corresponding to the â€œBraun-Blanquet (new)â€ scale, but with mixed character-numeric symbols replaced by integers: 1 = 1%, 2 = 2%, 3 = 3%, 4 = 4%, 5 = 8%, 6 = 18%, 7 = 38%, 8 = 68%, 9 = 88%\n06 â€“ Barkman, Doing & Segal: r = 1%, +r = 1%, +p = 1%, +a = 1%, +b = 2%, 1p = 1%, 1a = 2%, 1b = 3%, 2m = 4%, 2a = 8%, 2b = 18%, 3a = 31%, 3b = 43%, 4a = 56%, 4b = 68%, 5a = 81%, 5b = 93%\n07 â€“ Doing: r = 1%, p = 1%, a = 2%, m = 4%, 1 = 10%, 2 = 20%, 3 = 30%, 4 = 40%, 5 = 50%, 6 = 60%, 7 = 70%, 8 = 80%, 9 = 90%, 10 = 97%\n08 â€“ Domin: + = 1%, 1 = 2%, 2 = 3%, 3 = 4%, 4 = 13%, 5 = 23%, 6 = 29%, 7 = 42%, 8 = 63%, 9 = 88%, 10 = 99%\n10 â€“ ZlatnÃ­k: - = 1%, + = 2%, 1 = 3%, -2 = 10%, +2 = 20%, -3 = 31%, +3 = 44%, -4 = 56%, +4 = 69%, -5 = 81%, +5 = 94%\n14 â€“ Domin-HadaÄ: + = 0.5%, 1 = 1%, 2 = 2%, 3 = 4%, 4 = 10%, 5 = 20%, 6 = 29%, 7 = 42%, 8 = 63%, 9 = 85%, 10 = 98%\n15 â€“ Percentual (r, +): r = 0.1%, + = 0.5%, and integer values corresponding to percentages\n18 â€“ Hult-Sernader-DuRietz: r = 0.1%, + = 0.5%, 1 = 3.5%, 2 = 8.3%, 3 = 18.3%, 4 = 37.5%, 5 = 62.5%, 6 = 87.5\n\nAuthor code (AUTHOR). Code of the author of the vegetation plot.\nDate (DATE). Date of vegetation plot sampling, recorded in the format YYYYMMDD.\nSyntaxon (SYNTAXON). Vegetation unit (syntaxon) to which the vegetation plot was subjectively assigned by its author or a database administrator, according to the classification system in the publication:\n\nChytrÃ½ M. (ed.) (2007â€“2013): Vegetace ÄŒeskÃ© republiky 1â€“4. Vegetation of the Czech Republic 1â€“4. Academia, Praha.\n\nESy code (ESY_CODE). Code of the vegetation unit according to the Vegetation of the Czech Republic (ChytrÃ½ 2007â€“2013), assigned based on vegetation classification by the expert system CzechVeg-Esy, version v1-2020-01-12 (https://doi.org/10.5281/zenodo.3605562). This field is empty for plots that were not unambiguously classified by the expert system.\nESy name (ESY_NAME). Name of the vegetation unit according to the Vegetation of the Czech Republic (ChytrÃ½ 2007â€“2013), assigned based on vegetation classification by the expert system CzechVeg-Esy, version v1-2020-01-12 (https://doi.org/10.5281/zenodo.3605562). This field is empty for plots that were not unambiguously classified by the expert system.\nSyntaxon code (ESY_K_CODE). Code of the vegetation unit according to the expert system (taken from the ESy code variable), which is supplemented by subjective classification from the Syntaxon field for plots not classified by the expert system .\nSyntaxon name (ESY_K_NAME). Name of the vegetation unit according to the expert system (taken from the ESy code variable), which is supplemented by subjective classification from the Syntaxon field for plots not classified by the expert system.\nRelevÃ© area (SURF_AREA). Area of the vegetation plot in mÂ². A value of -1 represents missing data.\nAltitude (ALTITUDE). Altitude of the vegetation plot in meters. A value of -1 represents missing data.\nAspect (EXPOSITION). Slope aspect in azimuth degrees from 1 to 360Â°.\nSlope (INCLINATIO). Slope inclination in degrees. A value of -1 represents missing data.\nCover total (COV_TOTAL). Total percentage cover of all vegetation layers. A value of -1 represents missing data.\nCover tree layer (COV_TREES). Percentage cover of the tree layer. A value of -1 represents missing data.\nCover shrub layer (COV_SHRUBS). Percentage cover of the shrub layer. A value of -1 represents missing data.\nCover herb layer (COV_HERBS). Percentage cover of the herb layer. A value of -1 represents missing data.\nCover moss layer (COV_MOSSES). Percentage cover of the moss layer, including bryophytes and lichens. A value of -1 represents missing data.\nHeight (high) tree layer (TREE_HIGH). Height of the tree layer in meters. If the height of the higher and lower sublayers was estimated separately, this field contains the height of the higher sublayer.\nHeight (high) shrub layer (SHRUB_HIGH). Height of the shrub layer in meters. If the height of the higher and lower sublayers was estimated separately, this field contains the height of the higher sublayer.\nHeight (high) herb layer (HERB_HIGH). Height of the herb layer in centimeters. If the height of the higher and lower sublayers was estimated separately, this field contains the height of the higher sublayer.\nMaximum height herb layer (HERB_MAX). Height of the tallest herbs exceeding the general herb layer level, in centimeters.\nMosses identified (MOSS_IDENT). Information on whether bryophytes were recorded and identified in the vegetation plot.\nLichens identified (LICH_IDENT). Information on whether lichens were recorded and identified in the vegetation plot.\nCoordinate source (COORD_CODE). Method used to determine the coordinates of the vegetation plot, either in the field using a GPS receiver or subsequently using electronic or paper maps.\n\n01 â€“ GPS\n02 â€“ GeobÃ¡ze 100 (electronic map 1 : 100,000)\n03 â€“ GeobÃ¡ze 50 (electronic map 1 : 50,000)\n04 â€“ VojenskÃ© mapy 50 (paper maps 1 : 50,000)\n05 â€“ ZM 5 (paper maps 1 : 5,000)\n06 â€“ ZM 10 (paper maps 1 : 10,000)\n07 â€“ ZM 25 (paper maps 1 : 25,000)\n08 â€“ ZM 50 (paper maps 1 : 50,000)\n09 â€“ GIS (electronic map)\n10 â€“ Military maps 25 (paper maps 1 : 25,000)\n11 â€“ www.mapy.cz (electronic map or orthophoto)\n12 â€“ www.atlas.cz (electronic map or orthophoto)\n13 â€“ Google Earth (orthophoto)\n\nLocality (LOCALITY). Verbal description of the locality of the vegetation plot.\nLongitude (LONGITUDE). Longitude in the format DDMMSS.SS in the WGS-84 system (e.g., 170322.55 corresponds to 17Â° 3â€™ 22.55â€™â€™ E).\nLatitude (LATITUDE). Latitude in the format DDMMSS.SS in the WGS-84 system (e.g., 492215.12 corresponds to 49Â° 22â€™ 15.12â€™â€™ N).\nPrecision (PRECISION). Estimated uncertainty of the given geographic coordinates in meters.\nBias GPS (BIAS_GPS). Uncertainty of geographic coordinates measured using GPS, in meters.\nField number (FIELD_NR). Field number or code of the vegetation plot used by its author.\nHabitat (HABITAT). Textual description of the abiotic or biotic environment in the vegetation plot and its close surroundings.\nGeology (GEOLOGY). Textual description of geological bedrock in the vegetation plot.\nSoil (SOIL). Textual description of soil in the vegetation plot.\n\n\n2.2. Header-data variables with outdated content replaced by new variables\nSyntaxon old (SYNTAX_OLD). Vegetation unit (syntaxon) to which the vegetation plot was subjectively assigned by its author or database administrator according to the outdated classification system in the publication:\n\nMoravec J., BalÃ¡tovÃ¡-TulÃ¡ÄkovÃ¡ E., BlaÅ¾kovÃ¡ D., HadaÄ E., HejnÃ½ S., HusÃ¡k Å ., JenÃ­k J., Kolbek J., Krahulec F., KropÃ¡Ä Z., NeuhÃ¤usl R., RybnÃ­Äek K., Å˜ehoÅ™ek V. & Vicherek J. (1995): RostlinnÃ¡ spoleÄenstva ÄŒeskÃ© republiky a jejich ohroÅ¾enÃ­. Ed. 2. SeveroÄeskou pÅ™Ã­rodou, PÅ™Ã­loha 1995: 1â€“206.\n\nBias min (BIAS_MIN). Estimated uncertainty of the given geographic coordinates in minutes. The first digit indicates uncertainty in minutes of longitude, and the second digit indicates uncertainty in minutes of latitude.\n\n\n2.3. Rarely or never used header-data variables\nUTM grid system code (UTM). Code of geographic position in the Universal Transverse Mercator (UTM) system.\nCover lichen layer (COV_LICHEN). Percentage cover of lichens. Usually left empty, as lichens are included in the moss layer.\nCover algae layer (COV_ALGAE). Percentage cover of algae. A value of -1 represents missing data.\nCover litter layer (COV_LITTER). Percentage cover of litter (dead plant material). A value of -1 represents missing data.\nCover open water (COV_WATER). Percentage cover of open water surface. A value of -1 represents missing data.\nCover bare rock (COV_ROCK). Percentage cover of rock outcrops and stones. A value of -1 represents missing data.\nHeight low tree layer (TREE_LOW). Height of the lower tree sublayer in meters.\nHeight low shrub layer (SHRUB_LOW). Height of the lower shrub sublayer in meters.\nHeight low herb layer (HERB_LOW). Height of the lower herb sublayer in centimeters.\nMaximum height cryptogam layer (CRYPT_HIGH). Height of the tallest bryophytes or lichens in centimeters.\nCEBA grid (CEBA_GRID). Localization of the vegetation plot in the grid used for Central European flora mapping (see https://pladias.cz/download/phytogeography), either into basic grid cells (CEBA, Central European Basic Area) of size 10â€™ Ã— 6â€™ minutes (e.g.Â 6062) or quadrants of these basic grid cells of size 5â€™ Ã— 3â€™ minutes (e.g.Â 6062c).\n\n\n2.4. Inconsistently used header data variables with non-unified content\nProject code (PROJECT). Project codes were entered by some data contributors and served their internal purposes. Within the entire Czech Vegetation Database, project codes are not unified. Consequently, the same project code used by different data contributors can refer to different projects.\n\n\n\n3. Remarks\nThe REMARKS field contains non-standardized textual comments, such as details of taxonomic interpretation of some taxa reported in the plot, the uncertainty level of identification of specific taxa, and sampling methods. There is one REMARKS field for each plot.",
    "crumbs": [
      "Data",
      "Data description"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/data_processing_tutorial.html",
    "href": "DataProcessingTutorial/data_processing_tutorial.html",
    "title": "Data processing tutorial",
    "section": "",
    "text": "Here we provide a tutorial on how to import data from the Turboveg database and how to process it in R, run basic analyses and prepare data for export to other formats.\n\nWe are using the tidyverse approach and tidy data rules. If you are interested in more details and links to additional literature, check our study materials here.\nFor data processing, we recommend using a project in Rstudio. The advantage of using projects, is that you can directly use the same structure with exactly the same paths as provided in this tutorial. For this, add a subfolder â€œdataâ€ directly to the main folder, to store all the data files.\nWe show all the data processing using an example of forest understory data from the Czech Vegetation Database. If you want to train in the same way as is described in the tutorials, you can download zip files with data here Link to Github folderor with the whole project here Link to Github folder.\nIn individual subchapters you can find instructions and individual parts of the code, which you can copy and insert them into your own script (use the copy icon in the upper right corner to copy individual code chunks).\n\nPlease note that we do not provide the whole script, but we encourage you to copy the code chunks from the examples here and use them to build your own script, adjusted to your needs.\nAt the beginning of your work, load the following libraries. If needed, first install missing libraries by function install.packages(\"packageName\")\n\nlibrary(foreign)   #for reading dbf files \nlibrary(tidyverse) #for data handling, pipes and visualisation \nlibrary(readxl)    #for data import directly from Excel \nlibrary(janitor)   #for unified, easy-to-handle format of variable names\n\nWe are using pipes %&gt;% throughout the scripts. Pipes allows the output of a previous command to be used as input to another command instead of using nested functions. It means that a pipe binds individual steps into a sequence and it reads from left to right. You can insert it into your code by pressing Ctrl+Shift+M.\nTo play a bit with the pipes, you can take part of the script, send it to the console with Ctrl+Enter and just try if and how it works without assigning it to the final object as in the picture below.",
    "crumbs": [
      "Data processing tutorial"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/export.html",
    "href": "DataProcessingTutorial/export.html",
    "title": "Export to other formats",
    "section": "",
    "text": "There are two main ways how the data can be organised across rows and columns. Wide or long format. We will show you an example of spruce forest data, where we recorded plant species in several sites and at each site we also estimated their abundance, here approximated as percentage cover (higher value means that the species covered larger area of the surveyed vegetation plot, but we do not give the area itself, just value relatively to the total area, i.e.Â percentage of total area). The covers of species might overlap, as they grow in different heights.\n\nWide format is more conservative and used in many older packages for ecological data analysis. In our example we list all species and the colums are used to indicate their abundance at each site. This is the way you need to prepare your species matrix for ordinations in vegan. However, wide format has also many cons.\nOne of them is the size of the file. In the example above, there are abundance of given plants in each of the site. When the species is present in just one site, here Trientalis europaea, it is still keeping space across the whole table, where there can be hundreds or thousands of sites. The table code is then of course memory demanding. Another disadvantage is that you cannot add easily new information to the listed species. If you for example want to separate species that are in a tree vegetation layer (recognised in vegetation ecology as 1), herb layer (6) and moss layer (9), you would have to add this information to the name of the species e.g.Â Picea_abies_1.\n\nLong format in contrast, is great for handling large datasets. We can also add any information, describing the data, such as vegetation layers, growth forms, native/alien status etc. After that we can very simply filter, summarise and calculate further statistics.\n\nlibrary(tidyverse) \nlibrary(readxl) \nlibrary(janitor)\n\nWe will upload the species data saved in a long format and transform it into a matrix =wide format, so that it can be used in specific ecological analyses e.g.Â in vegan. (For wide to long see study materials)\n\nspe &lt;- read_csv(\"data/spe.csv\") \n\nNew names:\nRows: 4583 Columns: 6\nâ”€â”€ Column specification\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Delimiter: \",\" chr\n(1): species dbl (5): ...1, releve_nr, nonvascular, layer, cover_perc\nâ„¹ Use `spec()` to retrieve the full column specification for this data. â„¹\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\nâ€¢ `` -&gt; `...1`\n\ntibble(spe)\n\n# A tibble: 4,583 Ã— 6\n    ...1 releve_nr species                   nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex digitata                      0     6        0.5\n 2     2    183111 Carpinus betulus                    0     7        3  \n 3     3    183111 Cytisus nigricans                   0     6        0.1\n 4     4    183111 Festuca ovina                       0     6        3  \n 5     5    183111 Fraxinus excelsior                  0     7        0.1\n 6     6    183111 Galium rotundifolium                0     6        0.1\n 7     7    183111 Hieracium lachenalii                0     6        3  \n 8     8    183111 Hieracium murorum                   0     6        0.5\n 9     9    183111 Hieracium sabaudum s.lat.           0     6        0.1\n10    10    183111 Hypericum perforatum                0     6        0.1\n# â„¹ 4,573 more rows\n\n\nWe can see that there are plant species names sorted by releve_nr, where each number indicates a vegetation record from one specific site (can be also called vegetation plot or sample). We may need to change the species names to be in the compact format, without any spaces, just underscores. For this we will use mutate function with str_replace (for string specification) indicating that each space should be changed to underscore and we will directly apply it to the original column.\n\nspe %&gt;%    \n  mutate(species = str_replace_all(species, \" \", \"_\"))\n\n# A tibble: 4,583 Ã— 6\n    ...1 releve_nr species                   nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex_digitata                      0     6        0.5\n 2     2    183111 Carpinus_betulus                    0     7        3  \n 3     3    183111 Cytisus_nigricans                   0     6        0.1\n 4     4    183111 Festuca_ovina                       0     6        3  \n 5     5    183111 Fraxinus_excelsior                  0     7        0.1\n 6     6    183111 Galium_rotundifolium                0     6        0.1\n 7     7    183111 Hieracium_lachenalii                0     6        3  \n 8     8    183111 Hieracium_murorum                   0     6        0.5\n 9     9    183111 Hieracium_sabaudum_s.lat.           0     6        0.1\n10    10    183111 Hypericum_perforatum                0     6        0.1\n# â„¹ 4,573 more rows\n\n\nWe have the condensed name with underscores, but there are still more variables in the table. We can either remove them or merge them to be included in the final wide format. Here we will go a bit against tidy rules and add the information about the vegetation layer directly to the variable Species using unite function from the package tidyr which merges strings from two or more columns into a new one: A+B =A_B. Default separator is again underscore, unless you specify it differently by sep=XX argument.\n\nArgument na.rm indicates what to do if in one of the combined columns there is no value but NA. We have set this argument to TRUE to remove the NA. If you keep it FALSE it can happen that in some data the new string will be a_NA or NA_b, or even NA_NA (see line 4 of our example).\nRemove argument set to TRUE will remove the original columns which we used to combine the new one (in the example above you will have only z). In our case we will keep original columns for visual checking and we will use select function in the next step to remove them.\nNote that function that works in an opposite direction is called separate or separate_wider_delim\n\nspe %&gt;%   \n  mutate(species = str_replace_all(species, \" \", \"_\"))%&gt;%   \n  unite(\"species_layer\", species,layer, na.rm = TRUE, remove = FALSE) \n\n# A tibble: 4,583 Ã— 7\n    ...1 releve_nr species_layer            species nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                    &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex_digitata_6         Carex_â€¦           0     6        0.5\n 2     2    183111 Carpinus_betulus_7       Carpinâ€¦           0     7        3  \n 3     3    183111 Cytisus_nigricans_6      Cytisuâ€¦           0     6        0.1\n 4     4    183111 Festuca_ovina_6          Festucâ€¦           0     6        3  \n 5     5    183111 Fraxinus_excelsior_7     Fraxinâ€¦           0     7        0.1\n 6     6    183111 Galium_rotundifolium_6   Galiumâ€¦           0     6        0.1\n 7     7    183111 Hieracium_lachenalii_6   Hieracâ€¦           0     6        3  \n 8     8    183111 Hieracium_murorum_6      Hieracâ€¦           0     6        0.5\n 9     9    183111 Hieracium_sabaudum_s.laâ€¦ Hieracâ€¦           0     6        0.1\n10    10    183111 Hypericum_perforatum_6   Hyperiâ€¦           0     6        0.1\n# â„¹ 4,573 more rows\n\n\nAt this point we have everything we need to use it as input for the wide format table: releve_nr. species_layer and values of the abundance saved as cover_perc. One more step is to select only these or to deselect (-) those not needed.\n\nspe %&gt;%   \n  mutate(species = str_replace_all(species, \" \", \"_\"))%&gt;%   \n  unite(\"species_layer\", species,layer, na.rm = TRUE, remove = FALSE)%&gt;%\n  select(releve_nr, species_layer, cover_perc)\n\n# A tibble: 4,583 Ã— 3\n   releve_nr species_layer               cover_perc\n       &lt;dbl&gt; &lt;chr&gt;                            &lt;dbl&gt;\n 1    183111 Carex_digitata_6                   0.5\n 2    183111 Carpinus_betulus_7                 3  \n 3    183111 Cytisus_nigricans_6                0.1\n 4    183111 Festuca_ovina_6                    3  \n 5    183111 Fraxinus_excelsior_7               0.1\n 6    183111 Galium_rotundifolium_6             0.1\n 7    183111 Hieracium_lachenalii_6             3  \n 8    183111 Hieracium_murorum_6                0.5\n 9    183111 Hieracium_sabaudum_s.lat._6        0.1\n10    183111 Hypericum_perforatum_6             0.1\n# â„¹ 4,573 more rows\n\n\nNow we can finaly use the pivot wider function to transform the data. We have to specify from where we are taking the names of new variables (names_from) and from where we should take the values which should appear in the table (values_from). Since we changed the format, all species, even those not occurring in that particular site/plot have to get some values. Therefore, one more step is to fill the empty cells by zeros using values_fill. In this case we can do that, because we know that if the species was absent its abundance was exactly 0.\n\nspe %&gt;%   \n  mutate(species = str_replace_all(species, \" \", \"_\"))%&gt;%   \n  unite(\"species_layer\", species,layer, na.rm = TRUE, remove = FALSE)%&gt;%\n  pivot_wider(names_from = species_layer, \n              values_from = cover_perc, \n              values_fill = 0) -&gt; spe_wide\n\n\ntibble(spe)\n\n# A tibble: 4,583 Ã— 6\n    ...1 releve_nr species                   nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex digitata                      0     6        0.5\n 2     2    183111 Carpinus betulus                    0     7        3  \n 3     3    183111 Cytisus nigricans                   0     6        0.1\n 4     4    183111 Festuca ovina                       0     6        3  \n 5     5    183111 Fraxinus excelsior                  0     7        0.1\n 6     6    183111 Galium rotundifolium                0     6        0.1\n 7     7    183111 Hieracium lachenalii                0     6        3  \n 8     8    183111 Hieracium murorum                   0     6        0.5\n 9     9    183111 Hieracium sabaudum s.lat.           0     6        0.1\n10    10    183111 Hypericum perforatum                0     6        0.1\n# â„¹ 4,573 more rows",
    "crumbs": [
      "Data processing tutorial",
      "Export to other formats"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/export.html#long-to-wide-format",
    "href": "DataProcessingTutorial/export.html#long-to-wide-format",
    "title": "Export to other formats",
    "section": "",
    "text": "There are two main ways how the data can be organised across rows and columns. Wide or long format. We will show you an example of spruce forest data, where we recorded plant species in several sites and at each site we also estimated their abundance, here approximated as percentage cover (higher value means that the species covered larger area of the surveyed vegetation plot, but we do not give the area itself, just value relatively to the total area, i.e.Â percentage of total area). The covers of species might overlap, as they grow in different heights.\n\nWide format is more conservative and used in many older packages for ecological data analysis. In our example we list all species and the colums are used to indicate their abundance at each site. This is the way you need to prepare your species matrix for ordinations in vegan. However, wide format has also many cons.\nOne of them is the size of the file. In the example above, there are abundance of given plants in each of the site. When the species is present in just one site, here Trientalis europaea, it is still keeping space across the whole table, where there can be hundreds or thousands of sites. The table code is then of course memory demanding. Another disadvantage is that you cannot add easily new information to the listed species. If you for example want to separate species that are in a tree vegetation layer (recognised in vegetation ecology as 1), herb layer (6) and moss layer (9), you would have to add this information to the name of the species e.g.Â Picea_abies_1.\n\nLong format in contrast, is great for handling large datasets. We can also add any information, describing the data, such as vegetation layers, growth forms, native/alien status etc. After that we can very simply filter, summarise and calculate further statistics.\n\nlibrary(tidyverse) \nlibrary(readxl) \nlibrary(janitor)\n\nWe will upload the species data saved in a long format and transform it into a matrix =wide format, so that it can be used in specific ecological analyses e.g.Â in vegan. (For wide to long see study materials)\n\nspe &lt;- read_csv(\"data/spe.csv\") \n\nNew names:\nRows: 4583 Columns: 6\nâ”€â”€ Column specification\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Delimiter: \",\" chr\n(1): species dbl (5): ...1, releve_nr, nonvascular, layer, cover_perc\nâ„¹ Use `spec()` to retrieve the full column specification for this data. â„¹\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\nâ€¢ `` -&gt; `...1`\n\ntibble(spe)\n\n# A tibble: 4,583 Ã— 6\n    ...1 releve_nr species                   nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex digitata                      0     6        0.5\n 2     2    183111 Carpinus betulus                    0     7        3  \n 3     3    183111 Cytisus nigricans                   0     6        0.1\n 4     4    183111 Festuca ovina                       0     6        3  \n 5     5    183111 Fraxinus excelsior                  0     7        0.1\n 6     6    183111 Galium rotundifolium                0     6        0.1\n 7     7    183111 Hieracium lachenalii                0     6        3  \n 8     8    183111 Hieracium murorum                   0     6        0.5\n 9     9    183111 Hieracium sabaudum s.lat.           0     6        0.1\n10    10    183111 Hypericum perforatum                0     6        0.1\n# â„¹ 4,573 more rows\n\n\nWe can see that there are plant species names sorted by releve_nr, where each number indicates a vegetation record from one specific site (can be also called vegetation plot or sample). We may need to change the species names to be in the compact format, without any spaces, just underscores. For this we will use mutate function with str_replace (for string specification) indicating that each space should be changed to underscore and we will directly apply it to the original column.\n\nspe %&gt;%    \n  mutate(species = str_replace_all(species, \" \", \"_\"))\n\n# A tibble: 4,583 Ã— 6\n    ...1 releve_nr species                   nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex_digitata                      0     6        0.5\n 2     2    183111 Carpinus_betulus                    0     7        3  \n 3     3    183111 Cytisus_nigricans                   0     6        0.1\n 4     4    183111 Festuca_ovina                       0     6        3  \n 5     5    183111 Fraxinus_excelsior                  0     7        0.1\n 6     6    183111 Galium_rotundifolium                0     6        0.1\n 7     7    183111 Hieracium_lachenalii                0     6        3  \n 8     8    183111 Hieracium_murorum                   0     6        0.5\n 9     9    183111 Hieracium_sabaudum_s.lat.           0     6        0.1\n10    10    183111 Hypericum_perforatum                0     6        0.1\n# â„¹ 4,573 more rows\n\n\nWe have the condensed name with underscores, but there are still more variables in the table. We can either remove them or merge them to be included in the final wide format. Here we will go a bit against tidy rules and add the information about the vegetation layer directly to the variable Species using unite function from the package tidyr which merges strings from two or more columns into a new one: A+B =A_B. Default separator is again underscore, unless you specify it differently by sep=XX argument.\n\nArgument na.rm indicates what to do if in one of the combined columns there is no value but NA. We have set this argument to TRUE to remove the NA. If you keep it FALSE it can happen that in some data the new string will be a_NA or NA_b, or even NA_NA (see line 4 of our example).\nRemove argument set to TRUE will remove the original columns which we used to combine the new one (in the example above you will have only z). In our case we will keep original columns for visual checking and we will use select function in the next step to remove them.\nNote that function that works in an opposite direction is called separate or separate_wider_delim\n\nspe %&gt;%   \n  mutate(species = str_replace_all(species, \" \", \"_\"))%&gt;%   \n  unite(\"species_layer\", species,layer, na.rm = TRUE, remove = FALSE) \n\n# A tibble: 4,583 Ã— 7\n    ...1 releve_nr species_layer            species nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                    &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex_digitata_6         Carex_â€¦           0     6        0.5\n 2     2    183111 Carpinus_betulus_7       Carpinâ€¦           0     7        3  \n 3     3    183111 Cytisus_nigricans_6      Cytisuâ€¦           0     6        0.1\n 4     4    183111 Festuca_ovina_6          Festucâ€¦           0     6        3  \n 5     5    183111 Fraxinus_excelsior_7     Fraxinâ€¦           0     7        0.1\n 6     6    183111 Galium_rotundifolium_6   Galiumâ€¦           0     6        0.1\n 7     7    183111 Hieracium_lachenalii_6   Hieracâ€¦           0     6        3  \n 8     8    183111 Hieracium_murorum_6      Hieracâ€¦           0     6        0.5\n 9     9    183111 Hieracium_sabaudum_s.laâ€¦ Hieracâ€¦           0     6        0.1\n10    10    183111 Hypericum_perforatum_6   Hyperiâ€¦           0     6        0.1\n# â„¹ 4,573 more rows\n\n\nAt this point we have everything we need to use it as input for the wide format table: releve_nr. species_layer and values of the abundance saved as cover_perc. One more step is to select only these or to deselect (-) those not needed.\n\nspe %&gt;%   \n  mutate(species = str_replace_all(species, \" \", \"_\"))%&gt;%   \n  unite(\"species_layer\", species,layer, na.rm = TRUE, remove = FALSE)%&gt;%\n  select(releve_nr, species_layer, cover_perc)\n\n# A tibble: 4,583 Ã— 3\n   releve_nr species_layer               cover_perc\n       &lt;dbl&gt; &lt;chr&gt;                            &lt;dbl&gt;\n 1    183111 Carex_digitata_6                   0.5\n 2    183111 Carpinus_betulus_7                 3  \n 3    183111 Cytisus_nigricans_6                0.1\n 4    183111 Festuca_ovina_6                    3  \n 5    183111 Fraxinus_excelsior_7               0.1\n 6    183111 Galium_rotundifolium_6             0.1\n 7    183111 Hieracium_lachenalii_6             3  \n 8    183111 Hieracium_murorum_6                0.5\n 9    183111 Hieracium_sabaudum_s.lat._6        0.1\n10    183111 Hypericum_perforatum_6             0.1\n# â„¹ 4,573 more rows\n\n\nNow we can finaly use the pivot wider function to transform the data. We have to specify from where we are taking the names of new variables (names_from) and from where we should take the values which should appear in the table (values_from). Since we changed the format, all species, even those not occurring in that particular site/plot have to get some values. Therefore, one more step is to fill the empty cells by zeros using values_fill. In this case we can do that, because we know that if the species was absent its abundance was exactly 0.\n\nspe %&gt;%   \n  mutate(species = str_replace_all(species, \" \", \"_\"))%&gt;%   \n  unite(\"species_layer\", species,layer, na.rm = TRUE, remove = FALSE)%&gt;%\n  pivot_wider(names_from = species_layer, \n              values_from = cover_perc, \n              values_fill = 0) -&gt; spe_wide\n\n\ntibble(spe)\n\n# A tibble: 4,583 Ã— 6\n    ...1 releve_nr species                   nonvascular layer cover_perc\n   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                           &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n 1     1    183111 Carex digitata                      0     6        0.5\n 2     2    183111 Carpinus betulus                    0     7        3  \n 3     3    183111 Cytisus nigricans                   0     6        0.1\n 4     4    183111 Festuca ovina                       0     6        3  \n 5     5    183111 Fraxinus excelsior                  0     7        0.1\n 6     6    183111 Galium rotundifolium                0     6        0.1\n 7     7    183111 Hieracium lachenalii                0     6        3  \n 8     8    183111 Hieracium murorum                   0     6        0.5\n 9     9    183111 Hieracium sabaudum s.lat.           0     6        0.1\n10    10    183111 Hypericum perforatum                0     6        0.1\n# â„¹ 4,573 more rows",
    "crumbs": [
      "Data processing tutorial",
      "Export to other formats"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/export.html#juice-input-files",
    "href": "DataProcessingTutorial/export.html#juice-input-files",
    "title": "Export to other formats",
    "section": "3.2 Juice input files",
    "text": "3.2 Juice input files",
    "crumbs": [
      "Data processing tutorial",
      "Export to other formats"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/turboveg_r.html",
    "href": "DataProcessingTutorial/turboveg_r.html",
    "title": "Turboveg to R",
    "section": "",
    "text": "The aim of this tutorial is to show you step by step how to import the data from Turboveg 2 to R and prepare it for further analyses.",
    "crumbs": [
      "Data processing tutorial",
      "Turboveg to R"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/turboveg_r.html#turboveg-data-format",
    "href": "DataProcessingTutorial/turboveg_r.html#turboveg-data-format",
    "title": "Turboveg to R",
    "section": "1.1 Turboveg data format",
    "text": "1.1 Turboveg data format\nTurboveg for Windows is a program designed for the storage, selection, and export of vegetation plot data (relevÃ©s). The data are divided among several files that are matched by either species ID or relevÃ© ID. You do not see this structure directly in the Turboveg interface, but you can find it in theÂ TurbowinÂ folder, subfolderÂ dataÂ and particular database (see example below).\n\nAt some point, you need to export the data and process them further. This can be done in a specialised software called JUICE, but also directly in R.\n\nTo get Turboveg data to R, you first need toÂ export the Turboveg databaseÂ to a folder where you want to process the data. This step requiresÂ the selection of all the plotsÂ you want to export. Alternatively, you can access the files directly in the data folder in Turbowin, but if you do something wrong here, you might completely lose your data.",
    "crumbs": [
      "Data processing tutorial",
      "Turboveg to R"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/turboveg_r.html#load-libraries",
    "href": "DataProcessingTutorial/turboveg_r.html#load-libraries",
    "title": "Turboveg to R",
    "section": "1.2 Load libraries",
    "text": "1.2 Load libraries\n\nlibrary(foreign)   #for reading dbf files \nlibrary(tidyverse) #for data handling, pipes and visualisation \nlibrary(readxl)    #for data import directly from Excel \nlibrary(janitor)   #for unified, easy-to-handle format of variable names",
    "crumbs": [
      "Data processing tutorial",
      "Turboveg to R"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/turboveg_r.html#import-env-file-header-data",
    "href": "DataProcessingTutorial/turboveg_r.html#import-env-file-header-data",
    "title": "Turboveg to R",
    "section": "1.3 Import env file = header data",
    "text": "1.3 Import env file = header data\n\n1.3.1 Import\nOne option is to check the exported database manually, open the file called tvhabita.dbf in Excel and save it as tvhabita.xlsx or tvhabita.csv (UTF 8 encoded) file into your data folder. Although it includes one more step outside R, it is still rather straightforward and it saves you troubles with different formats in Turboveg and in R (encoding issues).\nYou can then import the file from Excel\n\nenv &lt;- read_excel(\"data/tvhabita.xlsx\")\n\nor from a csv file, which is a slightly more universal option, and we will use it for the import of most of the files.\n\nenv &lt;- read_csv(\"data/tvhabita.csv\")\n\nRows: 137 Columns: 84\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (13): COUNTRY, COVERSCALE, AUTHOR, SYNTAXON, MOSS_IDENT, LICH_IDENT, REM...\ndbl (45): RELEVE_NR, DATE, SURF_AREA, ALTITUDE, EXPOSITION, INCLINATIO, COV_...\nlgl (26): REFERENCE, TABLE_NR, NR_IN_TAB, PROJECT, UTM, RESURVEY, FOR_EVA, R...\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nIf you check the imported names, they are rather difficult to handle.\n\nnames(env)\n\n [1] \"RELEVE_NR\"  \"COUNTRY\"    \"REFERENCE\"  \"TABLE_NR\"   \"NR_IN_TAB\" \n [6] \"COVERSCALE\" \"PROJECT\"    \"AUTHOR\"     \"DATE\"       \"SYNTAXON\"  \n[11] \"SURF_AREA\"  \"UTM\"        \"ALTITUDE\"   \"EXPOSITION\" \"INCLINATIO\"\n[16] \"COV_TOTAL\"  \"COV_TREES\"  \"COV_SHRUBS\" \"COV_HERBS\"  \"COV_MOSSES\"\n[21] \"COV_LICHEN\" \"COV_ALGAE\"  \"COV_LITTER\" \"COV_WATER\"  \"COV_ROCK\"  \n[26] \"TREE_HIGH\"  \"TREE_LOW\"   \"SHRUB_HIGH\" \"SHRUB_LOW\"  \"HERB_HIGH\" \n[31] \"HERB_LOW\"   \"HERB_MAX\"   \"CRYPT_HIGH\" \"MOSS_IDENT\" \"LICH_IDENT\"\n[36] \"REMARKS\"    \"COORD_CODE\" \"SYNTAX_OLD\" \"RESURVEY\"   \"FOR_EVA\"   \n[41] \"RS_PROJECT\" \"RS_SITE\"    \"RS_PLOT\"    \"RS_OBSERV\"  \"PLOT_SHAPE\"\n[46] \"MANIPULATE\" \"MANIPTYP\"   \"LOC_METHOD\" \"DATA_OWNER\" \"EVA_ACCESS\"\n[51] \"LONGITUDE\"  \"LATITUDE\"   \"PRECISION\"  \"LOCALITY\"   \"BIAS_MIN\"  \n[56] \"BIAS_GPS\"   \"CEBA_GRID\"  \"FIELD_NR\"   \"HABITAT\"    \"GEOLOGY\"   \n[61] \"SOIL\"       \"WATER_PH\"   \"S_PH_H2O\"   \"S_PH_KCL\"   \"S_PH_CACL2\"\n[66] \"SOIL_PH\"    \"CONDUCT\"    \"NR_ORIG\"    \"HLOUBK_CM\"  \"DNO\"       \n[71] \"CEL_PLO_M2\" \"ZAROST_PLO\" \"ESY_CODE\"   \"ESY_NAME\"   \"COV_WOOD\"  \n[76] \"SOIL_DPT\"   \"TRAMPLING\"  \"PLOT_TYPE\"  \"RS_CODE\"    \"RS_PROJTYP\"\n[81] \"RADIATION\"  \"HEAT\"       \"LES\"        \"NELES\"     \n\n\nTherefore, we will directly change them to tidy names with the clean_names function from the package janitor. An alternative is to rename them one by one using e.g.Â rename, but here we want to save time and effort.\n\nenv &lt;- read_csv(\"data/tvhabita.csv\")%&gt;% \n  clean_names() \n\nRows: 137 Columns: 84\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (13): COUNTRY, COVERSCALE, AUTHOR, SYNTAXON, MOSS_IDENT, LICH_IDENT, REM...\ndbl (45): RELEVE_NR, DATE, SURF_AREA, ALTITUDE, EXPOSITION, INCLINATIO, COV_...\nlgl (26): REFERENCE, TABLE_NR, NR_IN_TAB, PROJECT, UTM, RESURVEY, FOR_EVA, R...\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ntibble(env)\n\n# A tibble: 137 Ã— 84\n   releve_nr country reference table_nr nr_in_tab coverscale project author\n       &lt;dbl&gt; &lt;chr&gt;   &lt;lgl&gt;     &lt;lgl&gt;    &lt;lgl&gt;     &lt;chr&gt;      &lt;lgl&gt;   &lt;chr&gt; \n 1    183111 CZ      NA        NA       NA        02         NA      0832  \n 2    183112 CZ      NA        NA       NA        02         NA      0832  \n 3    183113 CZ      NA        NA       NA        02         NA      0832  \n 4    183114 CZ      NA        NA       NA        02         NA      0832  \n 5    183115 CZ      NA        NA       NA        02         NA      0832  \n 6    183116 CZ      NA        NA       NA        02         NA      0832  \n 7    183117 CZ      NA        NA       NA        02         NA      0832  \n 8    183118 CZ      NA        NA       NA        02         NA      0832  \n 9    183119 CZ      NA        NA       NA        02         NA      0832  \n10    183120 CZ      NA        NA       NA        02         NA      0832  \n# â„¹ 127 more rows\n# â„¹ 76 more variables: date &lt;dbl&gt;, syntaxon &lt;chr&gt;, surf_area &lt;dbl&gt;, utm &lt;lgl&gt;,\n#   altitude &lt;dbl&gt;, exposition &lt;dbl&gt;, inclinatio &lt;dbl&gt;, cov_total &lt;dbl&gt;,\n#   cov_trees &lt;dbl&gt;, cov_shrubs &lt;dbl&gt;, cov_herbs &lt;dbl&gt;, cov_mosses &lt;dbl&gt;,\n#   cov_lichen &lt;dbl&gt;, cov_algae &lt;dbl&gt;, cov_litter &lt;dbl&gt;, cov_water &lt;dbl&gt;,\n#   cov_rock &lt;dbl&gt;, tree_high &lt;dbl&gt;, tree_low &lt;dbl&gt;, shrub_high &lt;dbl&gt;,\n#   shrub_low &lt;dbl&gt;, herb_high &lt;dbl&gt;, herb_low &lt;dbl&gt;, herb_max &lt;dbl&gt;, â€¦\n\n\nNote that the pipe %&gt;% allows the output of a previous command to be used as input to another command instead of using nested functions. It means that a pipe binds individual steps into a sequence and it reads from left to right. You can insert it into your code using Ctrl+Shift+M.\n\nnames(env)\n\n [1] \"releve_nr\"  \"country\"    \"reference\"  \"table_nr\"   \"nr_in_tab\" \n [6] \"coverscale\" \"project\"    \"author\"     \"date\"       \"syntaxon\"  \n[11] \"surf_area\"  \"utm\"        \"altitude\"   \"exposition\" \"inclinatio\"\n[16] \"cov_total\"  \"cov_trees\"  \"cov_shrubs\" \"cov_herbs\"  \"cov_mosses\"\n[21] \"cov_lichen\" \"cov_algae\"  \"cov_litter\" \"cov_water\"  \"cov_rock\"  \n[26] \"tree_high\"  \"tree_low\"   \"shrub_high\" \"shrub_low\"  \"herb_high\" \n[31] \"herb_low\"   \"herb_max\"   \"crypt_high\" \"moss_ident\" \"lich_ident\"\n[36] \"remarks\"    \"coord_code\" \"syntax_old\" \"resurvey\"   \"for_eva\"   \n[41] \"rs_project\" \"rs_site\"    \"rs_plot\"    \"rs_observ\"  \"plot_shape\"\n[46] \"manipulate\" \"maniptyp\"   \"loc_method\" \"data_owner\" \"eva_access\"\n[51] \"longitude\"  \"latitude\"   \"precision\"  \"locality\"   \"bias_min\"  \n[56] \"bias_gps\"   \"ceba_grid\"  \"field_nr\"   \"habitat\"    \"geology\"   \n[61] \"soil\"       \"water_ph\"   \"s_ph_h2o\"   \"s_ph_kcl\"   \"s_ph_cacl2\"\n[66] \"soil_ph\"    \"conduct\"    \"nr_orig\"    \"hloubk_cm\"  \"dno\"       \n[71] \"cel_plo_m2\" \"zarost_plo\" \"esy_code\"   \"esy_name\"   \"cov_wood\"  \n[76] \"soil_dpt\"   \"trampling\"  \"plot_type\"  \"rs_code\"    \"rs_projtyp\"\n[81] \"radiation\"  \"heat\"       \"les\"        \"neles\"     \n\n\nPipe also enables us to see the output before saving the result. We want to select just a few variables for checking, but not overwrite the data, before we are happy with the selection. For example, here we see that the habitat information is not filled (returns NAs), so I will not use it.\n\nenv %&gt;% \n  select(releve_nr, habitat, latitude, longitude)\n\n# A tibble: 137 Ã— 4\n   releve_nr habitat latitude longitude\n       &lt;dbl&gt; &lt;lgl&gt;      &lt;dbl&gt;     &lt;dbl&gt;\n 1    183111 NA       492015.   163420 \n 2    183112 NA       492129.   163346.\n 3    183113 NA       492126.   162913.\n 4    183114 NA       490210.   162138.\n 5    183115 NA       490203.   162128.\n 6    183116 NA       490158.   162117.\n 7    183117 NA       490253.   162349.\n 8    183118 NA       490730.   161735.\n 9    183119 NA       490742.   161622.\n10    183120 NA       490814.   161507 \n# â„¹ 127 more rows\n\n\nWhen I am fine with the selection, I can rewrite the file\n\nenv &lt;- env %&gt;% \n  select(releve_nr, coverscale,field_nr, country, author, date, syntaxon, \n         altitude, exposition, inclinatio, \n         cov_trees, cov_shrubs, cov_herbs, cov_mosses, \n         latitude, longitude, precision, bias_min, bias_gps, locality )\n\nOr I can add all the steps I did so far into one pipeline and check the resulting dataset\n\nenv &lt;- read_csv(\"data/tvhabita.csv\")%&gt;% \n  clean_names() %&gt;% \n  select(releve_nr, coverscale, field_nr, country, author, date, syntaxon, \n         altitude, exposition, inclinatio, \n         cov_trees, cov_shrubs, cov_herbs, cov_mosses, \n         latitude, longitude, precision, bias_min, bias_gps, locality ) %&gt;% \n  glimpse()\n\nRows: 137 Columns: 84\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (13): COUNTRY, COVERSCALE, AUTHOR, SYNTAXON, MOSS_IDENT, LICH_IDENT, REM...\ndbl (45): RELEVE_NR, DATE, SURF_AREA, ALTITUDE, EXPOSITION, INCLINATIO, COV_...\nlgl (26): REFERENCE, TABLE_NR, NR_IN_TAB, PROJECT, UTM, RESURVEY, FOR_EVA, R...\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nRows: 137\nColumns: 20\n$ releve_nr  &lt;dbl&gt; 183111, 183112, 183113, 183114, 183115, 183116, 183117, 183â€¦\n$ coverscale &lt;chr&gt; \"02\", \"02\", \"02\", \"02\", \"02\", \"02\", \"02\", \"02\", \"02\", \"02\",â€¦\n$ field_nr   &lt;chr&gt; \"2/2007\", \"3/2007\", \"4/2007\", \"5/2007\", \"6/2007\", \"7/2007\",â€¦\n$ country    &lt;chr&gt; \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\",â€¦\n$ author     &lt;chr&gt; \"0832\", \"0832\", \"0832\", \"0832\", \"0832\", \"0832\", \"0832\", \"08â€¦\n$ date       &lt;dbl&gt; 20070702, 20070702, 20070702, 20070703, 20070703, 20070703,â€¦\n$ syntaxon   &lt;chr&gt; \"LDA01\", \"LDA01\", \"LDA\", \"LDA01\", \"LDA\", \"LD\", \"LBB\", \"LB\",â€¦\n$ altitude   &lt;dbl&gt; 458, 414, 379, 374, 380, 373, 390, 255, 340, 368, 356, 427,â€¦\n$ exposition &lt;dbl&gt; 150, 150, 210, NA, 170, 65, NA, 80, 220, 95, 200, 170, 130,â€¦\n$ inclinatio &lt;dbl&gt; 24, 13, 21, 0, 10, 6, 0, 38, 13, 29, 38, 27, 7, 22, 9, 21, â€¦\n$ cov_trees  &lt;dbl&gt; 80, 80, 75, 70, 65, 65, 85, 80, 70, 85, 45, 70, 65, 70, 80,â€¦\n$ cov_shrubs &lt;dbl&gt; 0, 0, 0, 0, 1, 0, 0, 20, 0, 15, 1, 0, 2, 1, 12, 0, 0, 0, 0,â€¦\n$ cov_herbs  &lt;dbl&gt; 25, 25, 30, 35, 60, 70, 70, 15, 75, 8, 75, 40, 60, 40, 60, â€¦\n$ cov_mosses &lt;dbl&gt; 10, 8, 10, 8, 3, 5, 5, 10, 3, 5, 20, 3, 5, 30, 1, 5, 1, 5, â€¦\n$ latitude   &lt;dbl&gt; 492015.3, 492128.9, 492126.4, 490210.2, 490203.1, 490158.5,â€¦\n$ longitude  &lt;dbl&gt; 163420.0, 163345.8, 162913.4, 162137.8, 162128.3, 162117.2,â€¦\n$ precision  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,â€¦\n$ bias_min   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,â€¦\n$ bias_gps   &lt;dbl&gt; 5, 6, 10, 6, 5, 6, 14, 6, 4, 5, 5, 5, 6, 6, 5, 11, 8, 7, 4,â€¦\n$ locality   &lt;chr&gt; \"SvinoÅ¡ice (Brno, KuÅ™im); 450 m SZ od stÅ™edu obce\", \"LaÅ¾anyâ€¦\n\n\nAnd save it for easier access. Always keep releve_nr and coverscale, as you will need them later.\n\nwrite.csv(env, \"data/env.csv\")\n\n*An alternative option is to directly import the file exported from the Turboveg database named tvhabita.dbf. Since dbf is a specific type of files and we need to use a specialised packages. Here I used read.dbf function from the foreign library.\n\nenv_dbf &lt;- read.dbf(\"data/tvhabita.dbf\", as.is = F) %&gt;%    \n  clean_names()\n\nCheck the structure, directly in R\n\nview(env_dbf)\n\nGet the list of the variable names\n\nnames(env_dbf)\n\n [1] \"releve_nr\"  \"country\"    \"reference\"  \"table_nr\"   \"nr_in_tab\" \n [6] \"coverscale\" \"project\"    \"author\"     \"date\"       \"syntaxon\"  \n[11] \"surf_area\"  \"utm\"        \"altitude\"   \"exposition\" \"inclinatio\"\n[16] \"cov_total\"  \"cov_trees\"  \"cov_shrubs\" \"cov_herbs\"  \"cov_mosses\"\n[21] \"cov_lichen\" \"cov_algae\"  \"cov_litter\" \"cov_water\"  \"cov_rock\"  \n[26] \"tree_high\"  \"tree_low\"   \"shrub_high\" \"shrub_low\"  \"herb_high\" \n[31] \"herb_low\"   \"herb_max\"   \"crypt_high\" \"moss_ident\" \"lich_ident\"\n[36] \"remarks\"    \"coord_code\" \"syntax_old\" \"resurvey\"   \"for_eva\"   \n[41] \"rs_project\" \"rs_site\"    \"rs_plot\"    \"rs_observ\"  \"plot_shape\"\n[46] \"manipulate\" \"maniptyp\"   \"loc_method\" \"data_owner\" \"eva_access\"\n[51] \"longitude\"  \"latitude\"   \"precision\"  \"locality\"   \"bias_min\"  \n[56] \"bias_gps\"   \"ceba_grid\"  \"field_nr\"   \"habitat\"    \"geology\"   \n[61] \"soil\"       \"water_ph\"   \"s_ph_h2o\"   \"s_ph_kcl\"   \"s_ph_cacl2\"\n[66] \"soil_ph\"    \"conduct\"    \"nr_orig\"    \"hloubk_cm\"  \"dno\"       \n[71] \"cel_plo_m2\" \"zarost_plo\" \"esy_code\"   \"esy_name\"   \"cov_wood\"  \n[76] \"soil_dpt\"   \"trampling\"  \"plot_type\"  \"rs_code\"    \"rs_projtyp\"\n[81] \"radiation\"  \"heat\"       \"les\"        \"neles\"     \n\n\nThere are several issues with this type of import, as there might be different encodings used in the original files, not compatible with R. For the Czech dataset, I needed to further change the encoding style, so that the diacritics in text columns is translated correctly.\nFirst we need to select the columns that include text and can have issues with diacritics and special symbols, e.g.Â remarks, localityâ€¦ I specify them in the brackets and use function iconv to change the encoding to UTF-8. You may need to play a bit to see if it works correctly and change the original type in the from argument. I added one more line to transform the dataframe to tibble, which is the data format used in tidyverse packages.\n\nenv_dbf %&gt;%   \n  mutate(across(c(remarks, locality, habitat, soil),\n                ~ iconv(.x, from = \"cp852\", to = \"UTF-8\"))) %&gt;%\n  select(locality, soil) %&gt;%\n  as_tibble()\n\n# A tibble: 137 Ã— 2\n   locality                                                                soil \n   &lt;chr&gt;                                                                   &lt;chr&gt;\n 1 SvinoÅ¡ice (Brno, KuÅ™im); 450 m SZ od stÅ™edu obce                        &lt;NA&gt; \n 2 LaÅ¾any (Brno, KuÅ™im); 1 km VSV od stÅ™edu obce                           &lt;NA&gt; \n 3 VÅ¡echovice (TiÅ¡nov); 500 m Z od stÅ™edu obce                             &lt;NA&gt; \n 4 Vedrovice (MoravskÃ½ Krumlov), KrumlovskÃ½ les; 2,2 km SZ od stÅ™edu obce  &lt;NA&gt; \n 5 Vedrovice (MoravskÃ½ Krumlov), KrumlovskÃ½ les; 2,1 km SZ od stÅ™edu obce  &lt;NA&gt; \n 6 Vedrovice (MoravskÃ½ Krumlov), KrumlovskÃ½ les; 2,2 km SZ od stÅ™edu obce  &lt;NA&gt; \n 7 Vedrovice (MoravskÃ½ Krumlov), KrumlovskÃ½ les; 3,3 km SSV od stÅ™edu obce &lt;NA&gt; \n 8 ÄŒuÄice (Oslavany), PÅ™Ã­rodnÃ­ park Oslava; 1,7 km JV od stÅ™edu obce       &lt;NA&gt; \n 9 ÄŒuÄice (Oslavany), PÅ™Ã­rodnÃ­ park Oslava; 1 km JJZ od stÅ™edu obce        &lt;NA&gt; \n10 Senorady (Oslavany), PÅ™Ã­rodnÃ­ park Oslava; 1,2 km SSV od stÅ™edu obce    &lt;NA&gt; \n# â„¹ 127 more rows\n\n\nIn the next step we select variables we want to keep further, which is useful, as the database structure also includes predefined variables, even if they are empty. Another advantage of the select function.\n\nenv &lt;- env_dbf %&gt;%\n  mutate(across(c(remarks, locality, habitat, soil),\n                ~ iconv(.x, from = \"cp852\", to = \"UTF-8\"))) %&gt;%\n  select(releve_nr, coverscale,field_nr, country, author, date, syntaxon, \n         altitude, exposition, inclinatio, \n         cov_trees, cov_shrubs, cov_herbs, cov_mosses, \n         latitude, longitude, precision, bias_min, bias_gps, locality )%&gt;%\n  as_tibble()\n\n\n\n1.3.2 Coordinates\nIn the Turboveg 2 databases, the geographical coordinates are stored in a format with DDMMSS.SS. To show the plots in the map or perform any spatial calculations, you will need to transform the coordinates to decimal degrees.\n\nThat is the purpose of the following function, where I specify which parts of the string are degrees (position 1-2), which are minutes (3-4) and seconds (5 to11) and how to transform them.\n\n coord_to_degrees &lt;- function(coord){\n  as.numeric(str_sub(coord, 1, 2)) + as.numeric(str_sub(coord, 3, 4)) / 60 + as.numeric(str_sub(coord, 5, 11)) / 3600\n}\n\nBelow I will check if it works as I need. Please consider that here we apply it to central European dataset and adjustments are needed in other countries e.g.Â if the coordinates are higher than 99Â° ~ DDDMMSS.SS\n\nenv %&gt;%\n  mutate(deg_lat = coord_to_degrees(latitude),\n         deg_lon = coord_to_degrees(longitude)) %&gt;% \n  select(releve_nr, latitude, deg_lat, longitude, deg_lon)\n\n# A tibble: 137 Ã— 5\n   releve_nr latitude deg_lat longitude deg_lon\n       &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n 1    183111  492015.    49.3   163420     16.6\n 2    183112  492129.    49.4   163346.    16.6\n 3    183113  492126.    49.4   162913.    16.5\n 4    183114  490210.    49.0   162138.    16.4\n 5    183115  490203.    49.0   162128.    16.4\n 6    183116  490158.    49.0   162117.    16.4\n 7    183117  490253.    49.0   162349.    16.4\n 8    183118  490730.    49.1   161735.    16.3\n 9    183119  490742.    49.1   161622.    16.3\n10    183120  490814.    49.1   161507     16.3\n# â„¹ 127 more rows\n\n\nIf I know I will need coordinates for mapping I will add the respective lines directly to my pipeline\n\nenv &lt;- read_csv(\"data/tvhabita.csv\")%&gt;% \n  clean_names() %&gt;% \n  mutate(deg_lat = coord_to_degrees(latitude),\n         deg_lon = coord_to_degrees(longitude)) %&gt;% \n  select(releve_nr, coverscale, field_nr, country, author, date, syntaxon, \n         altitude, exposition, inclinatio, \n         cov_trees, cov_shrubs, cov_herbs, cov_mosses, \n         deg_lat, deg_lon, precision, bias_min, bias_gps, locality) %&gt;% \n  glimpse()\n\nRows: 137 Columns: 84\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (13): COUNTRY, COVERSCALE, AUTHOR, SYNTAXON, MOSS_IDENT, LICH_IDENT, REM...\ndbl (45): RELEVE_NR, DATE, SURF_AREA, ALTITUDE, EXPOSITION, INCLINATIO, COV_...\nlgl (26): REFERENCE, TABLE_NR, NR_IN_TAB, PROJECT, UTM, RESURVEY, FOR_EVA, R...\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nRows: 137\nColumns: 20\n$ releve_nr  &lt;dbl&gt; 183111, 183112, 183113, 183114, 183115, 183116, 183117, 183â€¦\n$ coverscale &lt;chr&gt; \"02\", \"02\", \"02\", \"02\", \"02\", \"02\", \"02\", \"02\", \"02\", \"02\",â€¦\n$ field_nr   &lt;chr&gt; \"2/2007\", \"3/2007\", \"4/2007\", \"5/2007\", \"6/2007\", \"7/2007\",â€¦\n$ country    &lt;chr&gt; \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\", \"CZ\",â€¦\n$ author     &lt;chr&gt; \"0832\", \"0832\", \"0832\", \"0832\", \"0832\", \"0832\", \"0832\", \"08â€¦\n$ date       &lt;dbl&gt; 20070702, 20070702, 20070702, 20070703, 20070703, 20070703,â€¦\n$ syntaxon   &lt;chr&gt; \"LDA01\", \"LDA01\", \"LDA\", \"LDA01\", \"LDA\", \"LD\", \"LBB\", \"LB\",â€¦\n$ altitude   &lt;dbl&gt; 458, 414, 379, 374, 380, 373, 390, 255, 340, 368, 356, 427,â€¦\n$ exposition &lt;dbl&gt; 150, 150, 210, NA, 170, 65, NA, 80, 220, 95, 200, 170, 130,â€¦\n$ inclinatio &lt;dbl&gt; 24, 13, 21, 0, 10, 6, 0, 38, 13, 29, 38, 27, 7, 22, 9, 21, â€¦\n$ cov_trees  &lt;dbl&gt; 80, 80, 75, 70, 65, 65, 85, 80, 70, 85, 45, 70, 65, 70, 80,â€¦\n$ cov_shrubs &lt;dbl&gt; 0, 0, 0, 0, 1, 0, 0, 20, 0, 15, 1, 0, 2, 1, 12, 0, 0, 0, 0,â€¦\n$ cov_herbs  &lt;dbl&gt; 25, 25, 30, 35, 60, 70, 70, 15, 75, 8, 75, 40, 60, 40, 60, â€¦\n$ cov_mosses &lt;dbl&gt; 10, 8, 10, 8, 3, 5, 5, 10, 3, 5, 20, 3, 5, 30, 1, 5, 1, 5, â€¦\n$ deg_lat    &lt;dbl&gt; 49.33758, 49.35803, 49.35733, 49.03617, 49.03419, 49.03292,â€¦\n$ deg_lon    &lt;dbl&gt; 16.57222, 16.56272, 16.48706, 16.36050, 16.35786, 16.35478,â€¦\n$ precision  &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,â€¦\n$ bias_min   &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,â€¦\n$ bias_gps   &lt;dbl&gt; 5, 6, 10, 6, 5, 6, 14, 6, 4, 5, 5, 5, 6, 6, 5, 11, 8, 7, 4,â€¦\n$ locality   &lt;chr&gt; \"SvinoÅ¡ice (Brno, KuÅ™im); 450 m SZ od stÅ™edu obce\", \"LaÅ¾anyâ€¦\n\n\nand save it for later\n\nwrite.csv(env, \"data/env.csv\")",
    "crumbs": [
      "Data processing tutorial",
      "Turboveg to R"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/turboveg_r.html#import-spe-file-species-file-in-a-long-format",
    "href": "DataProcessingTutorial/turboveg_r.html#import-spe-file-species-file-in-a-long-format",
    "title": "Turboveg to R",
    "section": "1.4 Import spe file = species file in a long format",
    "text": "1.4 Import spe file = species file in a long format\nThe first option is again to open the tvabund.dbf in Excel, save it as tvabund.csv and import it to our environment in R. Again, I will use the clean_names function during import, so that we have the same style of the variable names.\n\ntvabund &lt;- read_csv(\"data/tvabund.csv\") %&gt;% \n  clean_names()\n\nRows: 4583 Columns: 5\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (1): COVER_CODE\ndbl (3): RELEVE_NR, SPECIES_NR, LAYER\nlgl (1): _ORIG_NAME\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n*An alternative option is to read the data directly from the dbf file. In this case, it is less complicated than the import of an env file, as there are no problematic text variables.\n\ntvabund &lt;- read.dbf(\"data/tvabund.dbf\", as.is = F) %&gt;% \n  clean_names()\n\n\nglimpse(tvabund)\n\nRows: 4,583\nColumns: 5\n$ releve_nr  &lt;dbl&gt; 183111, 183111, 183111, 183111, 183111, 183111, 183111, 183â€¦\n$ species_nr &lt;dbl&gt; 2206, 2315, 3351, 4283, 4430, 4577, 5127, 5137, 5165, 5353,â€¦\n$ cover_code &lt;chr&gt; \"+\", \"1\", \"r\", \"1\", \"r\", \"r\", \"1\", \"+\", \"r\", \"r\", \"2b\", \"+\"â€¦\n$ layer      &lt;dbl&gt; 6, 7, 6, 6, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 7, 6, 6, 6, 6,â€¦\n$ orig_name  &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,â€¦\n\n\nNow we will check the data again and we see, that there are no species names, just numbers. Also, the cover is given in the original codes and not in percentages. See the scheme below to understand where each piece of information is stored.\n\nWe have to prepare these different files we need, import them and merge them.\n\n1.4.1 Nomenclature\nIn the abund file, species numbers refer to the codes in the checklist used in the Turboveg database. To translate them into species names you will need a translation table with the original number in the database, the original name in the database and the name you want to use in the analyses.\n\nPreparation of the translation table: To show you how to prepare such a table, I opened the checklist file, so called species.dbf from the folder: Turbowin/species/CzechiaSlovakia2015 and saved it here in the data folder as species.csv. Using the following pipeline, you can prepare your own translation table and add other names or information.\n\nnomenclature_raw &lt;- read_csv(\"data/species.csv\") %&gt;%   \n  clean_names() %&gt;%   \n  left_join(select(., species_nr, accepted_abbreviat = abbreviat),     \n            by = c(\"valid_nr\" = \"species_nr\")) %&gt;%   \n  mutate(accepted_name = if_else(synonym, accepted_abbreviat, abbreviat)) %&gt;%\n  select(-accepted_abbreviat) \n\nRows: 13863 Columns: 6\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (3): LETTERCODE, SHORTNAME, ABBREVIAT\ndbl (2): SPECIES_NR, VALID_NR\nlgl (1): SYNONYM\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nWe will now import the nomenclature file that is already adapted for the Czech flora.\n\nnomenclature &lt;- read_csv(\"data/nomenclature_20251108.csv\") %&gt;%\n  clean_names()  \n\nRows: 13862 Columns: 7\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (4): LETTERCODE, TurbovegCzechiaSlovakia, Kaplan, ExpertSystem\ndbl (2): SPECIES_NR, nonvascular\nlgl (1): SYNONYM\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ntibble(nomenclature)\n\n# A tibble: 13,862 Ã— 7\n   species_nr lettercode synonym turboveg_czechia_slovakia  kaplan expert_system\n        &lt;dbl&gt; &lt;chr&gt;      &lt;lgl&gt;   &lt;chr&gt;                      &lt;chr&gt;  &lt;chr&gt;        \n 1      14321 *CONC*C    FALSE   x Conygeron huelsenii      x Conâ€¦ x Conyzigeroâ€¦\n 2      14323 *DACD*A    FALSE   x Dactylodenia gracilis    x Dacâ€¦ x Dactylogymâ€¦\n 3      14324 *DACD*A    TRUE    x Dactylodenia st.-quintiâ€¦ x Dacâ€¦ x Dactylogymâ€¦\n 4      14322 *DACD*D    FALSE   x Dactylodenia comigera    x Dacâ€¦ x Dactylogymâ€¦\n 5      14325 *DATD*D    FALSE   x Dactyloglossum erdingeri x Dacâ€¦ x Dactylogloâ€¦\n 6      14327 *FESF*E    FALSE   x Festulolium loliaceum    x Fesâ€¦ x Festuloliuâ€¦\n 7      14326 *FESF*F    FALSE   x Festulolium braunii      x Fesâ€¦ x Festuloliuâ€¦\n 8      14328 *GYMG*G    FALSE   x Gymnanacamptis anacamptâ€¦ x Gymâ€¦ x Gymnanacamâ€¦\n 9      14329 *ORCO*O    FALSE   x Orchidactyla boudieri    x Dacâ€¦ x Dactylocamâ€¦\n10      14330 *PSEP*P    FALSE   x Pseudadenia schweinfurtâ€¦ x Pseâ€¦ x Pseudadeniâ€¦\n# â„¹ 13,852 more rows\n# â„¹ 1 more variable: nonvascular &lt;dbl&gt;\n\n\nThere are several advantages of this approach. First, you can adjust the nomenclature to the newest source/regional checklist. In our example, the name in Turboveg is translated to the nomenclature presented in the recent edition of the Key to the Flora of the Czech Republick, and it is named after the main editor Kaplan.\nSecond, I can add a concept that groups several taxa into higher units, e.g.Â taxa that are not easy to recognise in the field are assigned into aggregates. This is exactly the same approach you use when creating an expert system file. Here it is even easier to understand and much easier to change the translation when you need to fix something. The name in this file is called ESy.\nLast but not least. I can directly add much more information into such a table. For example invasion status, growth form or anything else. Here we have an indication of whether the species is nonvascular.\nI might want to check how the species are translated using my translation file and select just these matching rows. Either create a variable called selection indicating if the species is in the subset or not.\n\nnomenclature_check&lt;- nomenclature %&gt;% \n  left_join(tvabund %&gt;% \n              distinct(species_nr)%&gt;%\n              mutate(selection=1)) \n\nJoining with `by = join_by(species_nr)`\n\n\nor I can even add the frequency, how many times it appears in the records of the dataset\n\nnomenclature_check&lt;- nomenclature %&gt;% \n  left_join(tvabund %&gt;% \n              count(species_nr)) \n\nJoining with `by = join_by(species_nr)`\n\n\nI can then write the file, make adjustments e.g.Â in Excel and upload it again. Great thing is that I have an indication of which species are in the dataset, and I do not have to pay attention to the other rows.\n\nwrite.csv(nomenclature_check, \"data/nomenclature_check.csv\")\n\nupload the new, adjusted file\n\nnomenclature &lt;- read_csv(\"data/nomenclature_check.csv\") %&gt;%\n  clean_names()  \n\n\n\n1.4.2 Cover\nWe have a translation table for nomenclature, but we still need to translate cover codes to percentages. For translation of cover we need to use information about the cover scale (stored in the header data / tvhabita / env file) and information on how to translate the values in that particular scale to percentages. The file here was prepared based on the translation of cover values in different scales to percentages following the EVA database approach. One more column was added to enable different adjustments, for example, change the values for rare species. For any project, we suggest to open the file and check if the scales you are using are there and if you agree with the translation.\n\ncover &lt;- read_csv(\"data/cover_20230402.csv\") %&gt;% clean_names()  \n\nRows: 326 Columns: 6\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (3): CoverScaleName, COVERSCALE, COVER_CODE\ndbl (3): ID, CoverPercEVA, CoverPerc\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ntibble(cover)\n\n# A tibble: 326 Ã— 6\n      id cover_scale_name coverscale cover_code cover_perc_eva cover_perc\n   &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;      &lt;chr&gt;               &lt;dbl&gt;      &lt;dbl&gt;\n 1     1 Percetage %      00         0.1                   0.1        0.1\n 2     2 Percetage %      00         0.2                   0.2        0.2\n 3     3 Percetage %      00         0.3                   0.3        0.3\n 4     4 Percetage %      00         0.4                   0.4        0.4\n 5     5 Percetage %      00         0.5                   0.5        0.5\n 6     6 Percetage %      00         0.6                   0.6        0.6\n 7     7 Percetage %      00         0.7                   0.7        0.7\n 8     8 Percetage %      00         0.8                   0.8        0.8\n 9     9 Percetage %      00         0.9                   0.9        0.9\n10    10 Percetage %      00         1                     1          1  \n# â„¹ 316 more rows\n\n\nHere I can check the different scale names included in the file\n\ncover %&gt;% distinct(cover_scale_name) \n\n# A tibble: 16 Ã— 1\n   cover_scale_name      \n   &lt;chr&gt;                 \n 1 Percetage %           \n 2 Braun/Blanquet (old)  \n 3 Braun/Blanquet (new)  \n 4 Londo                 \n 5 Presence/Absence      \n 6 Ordinale scale (1-9)  \n 7 Barkman, Doing & Segal\n 8 Doing                 \n 9 Domin                 \n10 Sedlakova             \n11 ZlatnË‡k               \n12 Percentual scale      \n13 Hedl                  \n14 KuÅºera                \n15 Domin (uprava Hadac)  \n16 Percentual (r, +)     \n\n\nAnd I can also filter the rows of the specified scales. E.g. here I am looking for all those that start with a specific pattern â€œBraunâ€\n\ncover %&gt;% \n  filter(str_starts(cover_scale_name, \"Braun\")) %&gt;% \n  print(n=20)\n\n# A tibble: 16 Ã— 6\n      id cover_scale_name     coverscale cover_code cover_perc_eva cover_perc\n   &lt;dbl&gt; &lt;chr&gt;                &lt;chr&gt;      &lt;chr&gt;               &lt;dbl&gt;      &lt;dbl&gt;\n 1   110 Braun/Blanquet (old) 01         r                       1        1  \n 2   111 Braun/Blanquet (old) 01         +                       2        2  \n 3   112 Braun/Blanquet (old) 01         1                       3        3  \n 4   113 Braun/Blanquet (old) 01         2                      13       13  \n 5   114 Braun/Blanquet (old) 01         3                      38       38  \n 6   115 Braun/Blanquet (old) 01         4                      63       63  \n 7   116 Braun/Blanquet (old) 01         5                      88       88  \n 8   117 Braun/Blanquet (new) 02         r                       1        0.1\n 9   118 Braun/Blanquet (new) 02         +                       2        0.5\n10   119 Braun/Blanquet (new) 02         1                       3        3  \n11   120 Braun/Blanquet (new) 02         2m                      4        4  \n12   121 Braun/Blanquet (new) 02         2a                      8       10  \n13   122 Braun/Blanquet (new) 02         2b                     18       20  \n14   123 Braun/Blanquet (new) 02         3                      38       37.5\n15   124 Braun/Blanquet (new) 02         4                      63       62.5\n16   125 Braun/Blanquet (new) 02         5                      88       87.5\n\n\n\n\n1.4.2 Merging all files into complete spe file\nFinally, I have translation to nomenclature, to cover, so I need to put everything together.\n\ntvabund %&gt;% \n  left_join(nomenclature %&gt;% \n              select(species_nr, kaplan, expert_system, nonvascular)) %&gt;% \n  left_join(env %&gt;% select(releve_nr, coverscale)) %&gt;% \n  left_join(cover %&gt;% select(coverscale,cover_code,cover_perc))\n\nJoining with `by = join_by(species_nr)`\nJoining with `by = join_by(releve_nr)`\nJoining with `by = join_by(cover_code, coverscale)`\n\n\n# A tibble: 4,583 Ã— 10\n   releve_nr species_nr cover_code layer orig_name kaplan          expert_system\n       &lt;dbl&gt;      &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;lgl&gt;     &lt;chr&gt;           &lt;chr&gt;        \n 1    183111       2206 +              6 NA        Carex digitataâ€¦ Carex digitaâ€¦\n 2    183111       2315 1              7 NA        Carpinus betulâ€¦ Carpinus betâ€¦\n 3    183111       3351 r              6 NA        Cytisus nigricâ€¦ Cytisus nigrâ€¦\n 4    183111       4283 1              6 NA        Festuca ovina   Festuca ovina\n 5    183111       4430 r              7 NA        Fraxinus excelâ€¦ Fraxinus excâ€¦\n 6    183111       4577 r              6 NA        Galium rotundiâ€¦ Galium rotunâ€¦\n 7    183111       5127 1              6 NA        Hieracium lachâ€¦ Hieracium laâ€¦\n 8    183111       5137 +              6 NA        Hieracium muroâ€¦ Hieracium muâ€¦\n 9    183111       5165 r              6 NA        Hieracium sabaâ€¦ Hieracium saâ€¦\n10    183111       5353 r              6 NA        Hypericum perfâ€¦ Hypericum peâ€¦\n# â„¹ 4,573 more rows\n# â„¹ 3 more variables: nonvascular &lt;dbl&gt;, coverscale &lt;chr&gt;, cover_perc &lt;dbl&gt;\n\n\nThe output contains these variables\n \"releve_nr\"     \"species_nr\"    \"cover_code\"    \"layer\"         \"orig_name\"     \"kaplan\"        \"expert_system\" \"nonvascular\"   \"coverscale\"    \"cover_perc\"   \nIf I am satisfied with the result, I assign the pipeline into the spe file and add one more line to select just the needed variables. Here I decided to use the expert_system name and I renamed it directly in the select function.\n\nspe&lt;- tvabund %&gt;% \n  left_join(nomenclature %&gt;% \n              select(species_nr, kaplan, expert_system, nonvascular)) %&gt;% \n  left_join(env %&gt;% select(releve_nr, coverscale)) %&gt;% \n  left_join(cover %&gt;% select(coverscale,cover_code,cover_perc)) %&gt;%\n  # filter (!nonvascular=1) %&gt;% # optional to remove nonvasculars\n  select(releve_nr, species= expert_system, nonvascular, layer, cover_perc)\n\nJoining with `by = join_by(species_nr)`\nJoining with `by = join_by(releve_nr)`\nJoining with `by = join_by(cover_code, coverscale)`\n\n\nTo see the result we will use view\n\nview(spe)\n\nWe can again save the final file, to be easily accessible for later\n\nwrite.csv(spe, \"data/spe.csv\")",
    "crumbs": [
      "Data processing tutorial",
      "Turboveg to R"
    ]
  },
  {
    "objectID": "DataProcessingTutorial/turboveg_r.html#merging-of-species-covers-across-layers",
    "href": "DataProcessingTutorial/turboveg_r.html#merging-of-species-covers-across-layers",
    "title": "Turboveg to R",
    "section": "1.5 Merging of species covers across layers",
    "text": "1.5 Merging of species covers across layers\n\n1.5.1 Duplicate species records\nWhat is the problem? Sometimes we have some species names listed more than once in the same plot. Either because we changed the original concept (from subspecies to species level, or after additional identification) or because we recorded the same species in different layers. Depending on our further questions and analyses this might become minor or bigger problem.\n\nA&gt; In the first case, duplicate within one layer, I can fix the problem by summing the values for the same species in the same layer to get distinct species-layer combinations per plot. This is something we need to do. Otherwise our data would go against tidy approach and we will experience issues in joins, summarisation etc.\nB&gt; In the other case, duplicate across layers, the data are OK, because there is one more variable that makes it unique record (layer). But if we want to look at the whole community and e.g.Â calculate share of some life forms weighted by cover, etc. we again need to sum the values across layers and put all the species as they were in the same layer (this is then usually marked as 0).\n\n\n1.5.2 Duplicates checking\nWe recommend to always do the following check of the data. Simply group species by releves/plots and count if some of the species are at more rows.\n\nspe %&gt;%    \n  group_by(releve_nr, species, layer) %&gt;%    \n  count() %&gt;%   \n  filter(n&gt;1)   \n\n# A tibble: 2 Ã— 4\n# Groups:   releve_nr, species, layer [2]\n  releve_nr species              layer     n\n      &lt;dbl&gt; &lt;chr&gt;                &lt;dbl&gt; &lt;int&gt;\n1       132 Galium palustre agg.     6     2\n2    183182 Galium palustre agg.     6     2\n\n\nWe can see that in two releves/plots there is a conflict in the species Galium palustre agg. Most probably we separated two species in the field that we later on decided to group into this aggregate. We can go back and check where exactly this happened, by exactly specifying where to look.\n\ntvabund %&gt;%    \n  select(releve_nr, species_nr)%&gt;%   \n  left_join(nomenclature %&gt;%                \n              select(species_nr, turboveg= turboveg_czechia_slovakia,  species=expert_system)) %&gt;%   \n  filter(releve_nr %in% c(132, 183182) & species ==\"Galium palustre agg.\")   \n\nJoining with `by = join_by(species_nr)`\n\n\n# A tibble: 4 Ã— 4\n  releve_nr species_nr turboveg         species             \n      &lt;dbl&gt;      &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;               \n1    183182       4558 Galium elongatum Galium palustre agg.\n2    183182       4570 Galium palustre  Galium palustre agg.\n3       132       4558 Galium elongatum Galium palustre agg.\n4       132       4570 Galium palustre  Galium palustre agg.\n\n\nAlternatively, I can save the first output and use semi-join function, which is very useful if there are more rows I want to check and I do not need to specify multiple conditions in the filter.\n\ntest&lt;-spe %&gt;%    \n  group_by(releve_nr, species, layer) %&gt;%    \n  count() %&gt;%   \n  filter(n&gt;1)   \n\ntvabund %&gt;%    \n  select(releve_nr, species_nr)%&gt;%   \n  left_join(nomenclature %&gt;%                \n              select(species_nr, turboveg= turboveg_czechia_slovakia, species=expert_system)) %&gt;%   \n  semi_join(test)\n\nJoining with `by = join_by(species_nr)`\nJoining with `by = join_by(releve_nr, species)`\n\n\n# A tibble: 4 Ã— 4\n  releve_nr species_nr turboveg         species             \n      &lt;dbl&gt;      &lt;dbl&gt; &lt;chr&gt;            &lt;chr&gt;               \n1    183182       4558 Galium elongatum Galium palustre agg.\n2    183182       4570 Galium palustre  Galium palustre agg.\n3       132       4558 Galium elongatum Galium palustre agg.\n4       132       4570 Galium palustre  Galium palustre agg.\n\n\nOK, I understand why it happened and I have to fix it now. But we continue checking. Now we will check if there is also problem with species across layers (B). I will simply change the grouping conditions, to the higher hierarchy.\n\nspe %&gt;%    \n  group_by(releve_nr, species) %&gt;%    \n  count() %&gt;%   \n  filter(n&gt;1)\n\n# A tibble: 375 Ã— 3\n# Groups:   releve_nr, species [375]\n   releve_nr species                  n\n       &lt;dbl&gt; &lt;chr&gt;                &lt;int&gt;\n 1         1 Acer campestre           2\n 2         1 Quercus petraea agg.     2\n 3         2 Quercus petraea agg.     2\n 4         3 Quercus petraea agg.     2\n 5         4 Carpinus betulus         2\n 6         4 Quercus petraea agg.     2\n 7         5 Quercus petraea agg.     2\n 8         6 Ligustrum vulgare        2\n 9         6 Quercus petraea agg.     2\n10         6 Rosa species             2\n# â„¹ 365 more rows\n\n\nWe got lot of duplicates, right? But it is understandable in the vegetation type we have. So keep it in mind for later analyses.\nSometimes it is good to take some extra time and just look at what is inside. Are there just trees recorded also as shrubs and juveniles or are there some herbs by mistake included in tree layer? Add %&gt;% view () to see the whole list.\n\nspe %&gt;%    \n  distinct(species,layer)%&gt;%   \n  group_by(species) %&gt;%    \n  count() %&gt;%   \n  filter(n&gt;1) \n\n# A tibble: 38 Ã— 2\n# Groups:   species [38]\n   species                    n\n   &lt;chr&gt;                  &lt;int&gt;\n 1 Acer campestre             3\n 2 Acer platanoides           3\n 3 Acer pseudoplatanus        3\n 4 Aesculus hippocastanum     2\n 5 Alnus glutinosa            3\n 6 Alnus incana               3\n 7 Carpinus betulus           3\n 8 Cornus mas                 2\n 9 Cornus sanguinea           2\n10 Corylus avellana           3\n# â„¹ 28 more rows\n\n\n\n\n1.5.3 Fixing duplicate rows\nNow finally the fixing. For some questions the most easiest thing how to resolve duplicate rows is to select only the relevant variables and groups and use distinct function. E.g. for species richness this would be enough. BUT we will lose information about the abundance, in our case percentage cover of each species.\n\nspe %&gt;%    \n  distinct(releve_nr, species,layer)\n\n# A tibble: 4,581 Ã— 3\n   releve_nr species                   layer\n       &lt;dbl&gt; &lt;chr&gt;                     &lt;dbl&gt;\n 1    183111 Carex digitata                6\n 2    183111 Carpinus betulus              7\n 3    183111 Cytisus nigricans             6\n 4    183111 Festuca ovina                 6\n 5    183111 Fraxinus excelsior            7\n 6    183111 Galium rotundifolium          6\n 7    183111 Hieracium lachenalii          6\n 8    183111 Hieracium murorum             6\n 9    183111 Hieracium sabaudum s.lat.     6\n10    183111 Hypericum perforatum          6\n# â„¹ 4,571 more rows\n\n\nThe percentage cover is estimated visually relative to the total area. In the field it is estimated indepently of other plants, because we know that the plants overlap within vertical space. If we use normal sum function, we can easily get total cover per plot above 100%. Although we can separate the information into vegetation layers, it is still rather coarse division. Especially in grasslands where the main diversity is in just one, often very dense, layer.\nTherefore we will use the approach suggested by H.S. Fischer in the paper On combination of species from different vegetation layers (AVS 2014), where he suggested summing up covers considering overlap among species, so that the overall maximum value is 100 and all the values are adjusted relative to this treshold. We will prepare function called combine_cover\n\ncombine_cover &lt;- function(x){\n  while (length(x)&gt;1){\n    x[2] &lt;- x[1]+(100-x[1])*x[2]/100\n    x &lt;- x[-1]\n  }\n  return(x)\n}\n\nA, Now letâ€™s check how it works. We will first fix the issue with duplicates within the same layer (A)\n\nspe %&gt;%    \n  group_by(releve_nr, species, layer) %&gt;%    \n  summarise(cover_perc_new = combine_cover(cover_perc)) \n\n`summarise()` has grouped output by 'releve_nr', 'species'. You can override\nusing the `.groups` argument.\n\n\n# A tibble: 4,581 Ã— 4\n# Groups:   releve_nr, species [4,144]\n   releve_nr species                  layer cover_perc_new\n       &lt;dbl&gt; &lt;chr&gt;                    &lt;dbl&gt;          &lt;dbl&gt;\n 1         1 Acer campestre               1           20  \n 2         1 Acer campestre               7            0.5\n 3         1 Acer platanoides             7            0.1\n 4         1 Anemone species              6            0.5\n 5         1 Bromus benekenii             6            0.1\n 6         1 Carex digitata               6            3  \n 7         1 Carex michelii               6            0.1\n 8         1 Carex montana                6            0.5\n 9         1 Carpinus betulus             7            0.5\n10         1 Cephalanthera damasonium     6            0.1\n# â„¹ 4,571 more rows\n\n\nand we will add the pipelines for checking if there are still some duplicate rows. Note summarise finished the group_by function, so I have to specify the grouping again in the count (or add the group_by before count again).\n\nspe %&gt;%    \n  group_by(releve_nr, species, layer) %&gt;%    \n  summarize(cover_perc_new = combine_cover(cover_perc))%&gt;%   \n  count(releve_nr, species, layer) %&gt;%   \n  filter(n&gt;1)\n\n# A tibble: 0 Ã— 4\n# Groups:   releve_nr, species [0]\n# â„¹ 4 variables: releve_nr &lt;dbl&gt;, species &lt;chr&gt;, layer &lt;dbl&gt;, n &lt;int&gt;\n\n\nWhen the output have no rows, it means our attempt solved the issue.\nIf I am happy, I overwrite cover directly, save the output for easier access (next time you can start with reloading this file) or I will assign the whole pipeline into a new object e.g.Â -&gt;spe_merged\n\nspe %&gt;% \n  group_by(releve_nr, species, layer) %&gt;% \n  summarize(cover_perc = combine_cover(cover_perc))%&gt;%\n  write_csv(\"data/spe_merged_covers.csv\")\n\n`summarise()` has grouped output by 'releve_nr', 'species'. You can override\nusing the `.groups` argument.\n\n\nB, We want to also remove information about layer and work at whole community level. This means we will do the same, we will just not add the layer into grouping, as we do not want to pay attention to it anymore.\n\nspe %&gt;% \n  group_by(releve_nr, species) %&gt;% \n  summarize(cover_perc = combine_cover(cover_perc))%&gt;%\n  write_csv(\"data/spe_merged_covers_across_layers.csv\")\n\n\n\n1.5.4 Total cover of all species in the plot\nThe same approach as we did for merging covers can be used also for calculating total cover in the plot. Here you can see the comparison of total cover calculated as ordinary sum and total cover calculated with considering the overlaps.\n\nspe %&gt;% \n  group_by(releve_nr) %&gt;% \n  summarize(covertotal_sum = sum(cover_perc), \n            covertotal_overlap = combine_cover(cover_perc)) %&gt;%\n  select(releve_nr, covertotal_sum, covertotal_overlap)%&gt;%\n  arrange(desc(covertotal_sum))\n\n# A tibble: 137 Ã— 3\n   releve_nr covertotal_sum covertotal_overlap\n       &lt;dbl&gt;          &lt;dbl&gt;              &lt;dbl&gt;\n 1    183134           253                95.7\n 2       125           232.               93.3\n 3    183175           232.               93.3\n 4       131           223.               92.4\n 5    183181           223.               92.4\n 6       130           201.               92.4\n 7    183180           201.               92.4\n 8       129           192.               89.4\n 9    183179           192.               89.4\n10       113           192.               90.4\n# â„¹ 127 more rows\n\n\nThe same with respect to layers\n\nspe %&gt;% \n  group_by(releve_nr, layer) %&gt;% \n  summarize(covertotal_sum = sum(cover_perc), \n            covertotal_overlap = combine_cover(cover_perc)) %&gt;%\n  select(releve_nr, layer, covertotal_sum, covertotal_overlap)\n\n`summarise()` has grouped output by 'releve_nr'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 499 Ã— 4\n# Groups:   releve_nr [137]\n   releve_nr layer covertotal_sum covertotal_overlap\n       &lt;dbl&gt; &lt;dbl&gt;          &lt;dbl&gt;              &lt;dbl&gt;\n 1         1     1           82.5              70   \n 2         1     4           13.5              13.1 \n 3         1     6           22.2              20.1 \n 4         1     7           10                 9.64\n 5         2     1           62.5              62.5 \n 6         2     6           31.5              28.8 \n 7         2     7           13.1              12.8 \n 8         3     1           62.5              62.5 \n 9         3     6           23.8              21.5 \n10         3     7            4                 4   \n# â„¹ 489 more rows",
    "crumbs": [
      "Data processing tutorial",
      "Turboveg to R"
    ]
  }
]